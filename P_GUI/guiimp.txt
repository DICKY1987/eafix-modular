🤖 HUEY_P GUI Implementation Guide for Agentic AI
Version: 1.0 | Target: Complete GUI Modernization | Estimated Implementation: 40-60 hours

📋 CRITICAL SETUP INSTRUCTIONS
1. Environment Preparation
bash# Install all required dependencies
pip install customtkinter==5.2.0
pip install ttkbootstrap==1.10.1
pip install tkinter-tooltip==3.0.0
pip install pygame==2.5.2
pip install pillow==10.0.0
pip install numpy==1.24.3
pip install pandas==2.0.3
pip install matplotlib==3.7.2
pip install plotly==5.15.0
pip install pywin32==306
pip install asyncio-mqtt==0.13.0
2. Project Structure Creation
Create this EXACT directory structure:
huey_p_gui/
├── src/
│   ├── ui/
│   │   ├── __init__.py
│   │   ├── risk_ribbon.py
│   │   ├── strength_tab.py
│   │   ├── indicator_tab.py
│   │   ├── rule_matrix.py
│   │   ├── readiness_card.py
│   │   ├── command_palette.py
│   │   ├── toast_manager.py
│   │   └── modern_widgets.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── event_bus.py
│   │   ├── state_manager.py
│   │   ├── performance.py
│   │   └── risk_engine.py
│   ├── themes/
│   │   ├── __init__.py
│   │   ├── dark_theme.py
│   │   └── colors.py
│   └── assets/
│       ├── sounds/
│       │   ├── warning.wav
│       │   ├── danger.wav
│       │   └── emergency.wav
│       └── icons/
├── config/
│   ├── ui_settings.json
│   └── risk_constraints.json
└── tests/
    ├── test_risk_ribbon.py
    ├── test_event_bus.py
    └── test_ui_components.py

🎯 PHASE 1: CORE INFRASTRUCTURE (Day 1-2)
Step 1.1: Event Bus Implementation
File: src/core/event_bus.py
python"""
Event Bus Implementation for HUEY_P GUI
Handles all inter-component communication
"""

import threading
import time
from collections import defaultdict, deque
from typing import Dict, List, Callable, Any, Optional
from dataclasses import dataclass, asdict
from datetime import datetime
import json

@dataclass
class Event:
    """Standard event structure"""
    topic: str
    data: Dict[str, Any]
    timestamp: datetime
    source: str
    event_id: str

class EventBus:
    """Thread-safe event bus for GUI communication"""
    
    def __init__(self, max_history: int = 1000):
        self._subscribers: Dict[str, List[Callable]] = defaultdict(list)
        self._event_history: deque = deque(maxlen=max_history)
        self._lock = threading.RLock()
        self._running = True
        self._stats = {
            'events_published': 0,
            'events_failed': 0,
            'subscribers_count': 0
        }
        
    def subscribe(self, topic: str, callback: Callable[[Event], None]) -> str:
        """
        Subscribe to events on a specific topic
        
        Args:
            topic: Event topic to subscribe to
            callback: Function to call when event is published
            
        Returns:
            subscription_id: Unique identifier for this subscription
        """
        with self._lock:
            subscription_id = f"{topic}_{len(self._subscribers[topic])}"
            self._subscribers[topic].append(callback)
            self._stats['subscribers_count'] = sum(len(subs) for subs in self._subscribers.values())
            return subscription_id
    
    def unsubscribe(self, topic: str, callback: Callable) -> bool:
        """Remove subscription"""
        with self._lock:
            if topic in self._subscribers and callback in self._subscribers[topic]:
                self._subscribers[topic].remove(callback)
                self._stats['subscribers_count'] = sum(len(subs) for subs in self._subscribers.values())
                return True
            return False
    
    def publish(self, topic: str, data: Dict[str, Any], source: str = "unknown") -> str:
        """
        Publish event to all subscribers
        
        Args:
            topic: Event topic
            data: Event payload
            source: Source component name
            
        Returns:
            event_id: Unique event identifier
        """
        event_id = f"{topic}_{time.time()}"
        event = Event(
            topic=topic,
            data=data,
            timestamp=datetime.now(),
            source=source,
            event_id=event_id
        )
        
        with self._lock:
            self._event_history.append(event)
            self._stats['events_published'] += 1
            
            # Notify subscribers
            subscribers = self._subscribers.get(topic, [])
            failed_count = 0
            
            for callback in subscribers:
                try:
                    callback(event)
                except Exception as e:
                    failed_count += 1
                    print(f"Event callback failed: {e}")
                    
            if failed_count > 0:
                self._stats['events_failed'] += failed_count
                
        return event_id
    
    def get_stats(self) -> Dict[str, Any]:
        """Get event bus statistics"""
        with self._lock:
            return {
                **self._stats,
                'active_topics': list(self._subscribers.keys()),
                'total_subscribers': self._stats['subscribers_count']
            }
    
    def get_recent_events(self, count: int = 10, topic: Optional[str] = None) -> List[Event]:
        """Get recent events, optionally filtered by topic"""
        with self._lock:
            events = list(self._event_history)
            if topic:
                events = [e for e in events if e.topic == topic]
            return events[-count:]

# Global event bus instance
event_bus = EventBus()
Step 1.2: State Manager Implementation
File: src/core/state_manager.py
python"""
Centralized State Management for HUEY_P GUI
"""

from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List
from datetime import datetime
import json
import threading
from .event_bus import event_bus

@dataclass
class RiskMetrics:
    daily_drawdown: float = 0.0
    daily_limit: float = 2.0
    portfolio_risk: float = 0.0
    max_correlation: float = 0.0
    session_cap_used: float = 0.0
    session_cap_limit: float = 1.5
    last_update: datetime = field(default_factory=datetime.now)

@dataclass
class ConnectivityStatus:
    dde_connected: bool = False
    last_update: Optional[datetime] = None
    symbol_count: int = 0
    connection_quality: str = "unknown"  # "excellent", "good", "poor", "disconnected"

@dataclass
class MarketData:
    symbols: Dict[str, Dict[str, float]] = field(default_factory=dict)  # symbol -> {timeframe: pct_change}
    currency_strength: Dict[str, Dict[str, float]] = field(default_factory=dict)  # currency -> {timeframe: strength}
    last_update: datetime = field(default_factory=datetime.now)

@dataclass
class UIPreferences:
    theme: str = "dark"
    sound_enabled: bool = False
    update_frequency: int = 1000  # milliseconds
    risk_alert_threshold: float = 0.9
    column_widths: Dict[str, int] = field(default_factory=dict)
    workspace_layout: str = "default"

@dataclass
class SystemHealth:
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    frame_rate: float = 0.0
    event_queue_size: int = 0
    last_check: datetime = field(default_factory=datetime.now)

class StateManager:
    """Centralized state management with automatic persistence"""
    
    def __init__(self, config_path: str = "config/app_state.json"):
        self.config_path = config_path
        self._lock = threading.RLock()
        
        # Initialize state components
        self.risk_metrics = RiskMetrics()
        self.connectivity = ConnectivityStatus()
        self.market_data = MarketData()
        self.ui_preferences = UIPreferences()
        self.system_health = SystemHealth()
        
        # Load persisted state
        self.load_state()
        
        # Subscribe to events for state updates
        self._setup_event_handlers()
    
    def _setup_event_handlers(self):
        """Setup event handlers for state updates"""
        event_bus.subscribe("risk_update", self._handle_risk_update)
        event_bus.subscribe("connectivity_update", self._handle_connectivity_update)
        event_bus.subscribe("market_data_update", self._handle_market_data_update)
        event_bus.subscribe("ui_preferences_update", self._handle_ui_preferences_update)
        event_bus.subscribe("system_health_update", self._handle_system_health_update)
    
    def _handle_risk_update(self, event):
        """Handle risk metric updates"""
        with self._lock:
            data = event.data
            self.risk_metrics = RiskMetrics(
                daily_drawdown=data.get('daily_drawdown', self.risk_metrics.daily_drawdown),
                daily_limit=data.get('daily_limit', self.risk_metrics.daily_limit),
                portfolio_risk=data.get('portfolio_risk', self.risk_metrics.portfolio_risk),
                max_correlation=data.get('max_correlation', self.risk_metrics.max_correlation),
                session_cap_used=data.get('session_cap_used', self.risk_metrics.session_cap_used),
                session_cap_limit=data.get('session_cap_limit', self.risk_metrics.session_cap_limit),
                last_update=datetime.now()
            )
    
    def _handle_connectivity_update(self, event):
        """Handle connectivity status updates"""
        with self._lock:
            data = event.data
            self.connectivity = ConnectivityStatus(
                dde_connected=data.get('dde_connected', self.connectivity.dde_connected),
                last_update=datetime.now(),
                symbol_count=data.get('symbol_count', self.connectivity.symbol_count),
                connection_quality=data.get('connection_quality', self.connectivity.connection_quality)
            )
    
    def _handle_market_data_update(self, event):
        """Handle market data updates"""
        with self._lock:
            data = event.data
            if 'symbols' in data:
                self.market_data.symbols.update(data['symbols'])
            if 'currency_strength' in data:
                self.market_data.currency_strength.update(data['currency_strength'])
            self.market_data.last_update = datetime.now()
    
    def _handle_ui_preferences_update(self, event):
        """Handle UI preferences updates"""
        with self._lock:
            data = event.data
            for key, value in data.items():
                if hasattr(self.ui_preferences, key):
                    setattr(self.ui_preferences, key, value)
            self.save_state()  # Persist UI preferences immediately
    
    def _handle_system_health_update(self, event):
        """Handle system health updates"""
        with self._lock:
            data = event.data
            self.system_health = SystemHealth(
                cpu_usage=data.get('cpu_usage', self.system_health.cpu_usage),
                memory_usage=data.get('memory_usage', self.system_health.memory_usage),
                frame_rate=data.get('frame_rate', self.system_health.frame_rate),
                event_queue_size=data.get('event_queue_size', self.system_health.event_queue_size),
                last_check=datetime.now()
            )
    
    def get_risk_metrics(self) -> RiskMetrics:
        """Get current risk metrics"""
        with self._lock:
            return self.risk_metrics
    
    def get_connectivity_status(self) -> ConnectivityStatus:
        """Get current connectivity status"""
        with self._lock:
            return self.connectivity
    
    def get_market_data(self) -> MarketData:
        """Get current market data"""
        with self._lock:
            return self.market_data
    
    def get_ui_preferences(self) -> UIPreferences:
        """Get current UI preferences"""
        with self._lock:
            return self.ui_preferences
    
    def get_system_health(self) -> SystemHealth:
        """Get current system health"""
        with self._lock:
            return self.system_health
    
    def is_action_allowed(self) -> tuple[bool, str]:
        """Check if trading actions are allowed based on current state"""
        with self._lock:
            # Check connectivity
            if not self.connectivity.dde_connected:
                return False, "DDE connection lost"
            
            # Check daily drawdown limit
            dd_ratio = abs(self.risk_metrics.daily_drawdown) / self.risk_metrics.daily_limit
            if dd_ratio >= 1.0:
                return False, f"Daily drawdown limit reached ({self.risk_metrics.daily_limit}%)"
            
            # Check correlation limit
            if self.risk_metrics.max_correlation > 0.7:
                return False, f"Correlation too high ({self.risk_metrics.max_correlation:.2f} > 0.70)"
            
            # Check session cap
            if self.risk_metrics.session_cap_used >= self.risk_metrics.session_cap_limit:
                return False, f"Session cap reached ({self.risk_metrics.session_cap_limit}%)"
            
            return True, "Actions allowed"
    
    def save_state(self):
        """Save current state to disk"""
        try:
            state_dict = {
                'ui_preferences': {
                    'theme': self.ui_preferences.theme,
                    'sound_enabled': self.ui_preferences.sound_enabled,
                    'update_frequency': self.ui_preferences.update_frequency,
                    'risk_alert_threshold': self.ui_preferences.risk_alert_threshold,
                    'column_widths': self.ui_preferences.column_widths,
                    'workspace_layout': self.ui_preferences.workspace_layout
                }
            }
            
            with open(self.config_path, 'w') as f:
                json.dump(state_dict, f, indent=2)
                
        except Exception as e:
            print(f"Failed to save state: {e}")
    
    def load_state(self):
        """Load persisted state from disk"""
        try:
            with open(self.config_path, 'r') as f:
                state_dict = json.load(f)
                
            if 'ui_preferences' in state_dict:
                ui_prefs = state_dict['ui_preferences']
                self.ui_preferences = UIPreferences(
                    theme=ui_prefs.get('theme', 'dark'),
                    sound_enabled=ui_prefs.get('sound_enabled', False),
                    update_frequency=ui_prefs.get('update_frequency', 1000),
                    risk_alert_threshold=ui_prefs.get('risk_alert_threshold', 0.9),
                    column_widths=ui_prefs.get('column_widths', {}),
                    workspace_layout=ui_prefs.get('workspace_layout', 'default')
                )
                
        except FileNotFoundError:
            # First run, use defaults
            self.save_state()
        except Exception as e:
            print(f"Failed to load state: {e}")

# Global state manager instance
state_manager = StateManager()
Step 1.3: Theme System Implementation
File: src/themes/colors.py
python"""
Color System for HUEY_P Trading GUI
"""

from typing import Dict, Any

class ColorPalette:
    """Central color definitions for trading GUI"""
    
    # Base colors
    SUCCESS = "#1DB954"
    WARNING = "#FFC107" 
    DANGER = "#FF4D4F"
    INFO = "#2D9CDB"
    
    # Dark theme colors
    DARK_SURFACE = "#0F1115"
    DARK_SURFACE_VARIANT = "#1A1D23"
    DARK_TEXT_PRIMARY = "#E6E6E6"
    DARK_TEXT_SECONDARY = "#B3B3B3"
    DARK_BORDER = "#2A2D35"
    
    # Light theme colors
    LIGHT_SURFACE = "#FFFFFF"
    LIGHT_SURFACE_VARIANT = "#F5F5F5"
    LIGHT_TEXT_PRIMARY = "#1A1A1A"
    LIGHT_TEXT_SECONDARY = "#666666"
    LIGHT_BORDER = "#E0E0E0"
    
    # Risk level colors
    RISK_SAFE = "#00FF88"
    RISK_CAUTION = "#FFD700"
    RISK_WARNING = "#FF8C00"
    RISK_DANGER = "#FF4444"
    RISK_CRITICAL = "#CC0000"
    
    # Currency colors
    CURRENCY_COLORS = {
        "USD": "#2E8B57",  # Sea green
        "EUR": "#4169E1",  # Royal blue
        "GBP": "#DC143C",  # Crimson
        "JPY": "#FF6347",  # Tomato
        "CHF": "#8B4513",  # Saddle brown
        "AUD": "#FFD700",  # Gold
        "CAD": "#FF1493",  # Deep pink
        "NZD": "#00CED1"   # Dark turquoise
    }

def get_risk_color(risk_ratio: float) -> str:
    """Get color based on risk ratio (0.0 to 1.0+)"""
    if risk_ratio < 0.3:
        return ColorPalette.RISK_SAFE
    elif risk_ratio < 0.6:
        return ColorPalette.RISK_CAUTION
    elif risk_ratio < 0.8:
        return ColorPalette.RISK_WARNING
    elif risk_ratio < 1.0:
        return ColorPalette.RISK_DANGER
    else:
        return ColorPalette.RISK_CRITICAL

def get_currency_color(currency: str) -> str:
    """Get color for specific currency"""
    return ColorPalette.CURRENCY_COLORS.get(currency.upper(), ColorPalette.INFO)

def interpolate_color(color1: str, color2: str, ratio: float) -> str:
    """Interpolate between two hex colors"""
    # Convert hex to RGB
    def hex_to_rgb(hex_color):
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    
    def rgb_to_hex(rgb):
        return f"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}"
    
    rgb1 = hex_to_rgb(color1)
    rgb2 = hex_to_rgb(color2)
    
    # Interpolate each channel
    r = int(rgb1[0] + (rgb2[0] - rgb1[0]) * ratio)
    g = int(rgb1[1] + (rgb2[1] - rgb1[1]) * ratio)
    b = int(rgb1[2] + (rgb2[2] - rgb1[2]) * ratio)
    
    return rgb_to_hex((r, g, b))
File: src/themes/dark_theme.py
python"""
Dark Theme Configuration for CustomTkinter
"""

import customtkinter as ctk
from .colors import ColorPalette

def apply_dark_theme():
    """Apply dark theme configuration to CustomTkinter"""
    
    # Set appearance mode
    ctk.set_appearance_mode("dark")
    ctk.set_default_color_theme("dark-blue")
    
    # Custom color scheme
    dark_theme = {
        "CTk": {
            "fg_color": [ColorPalette.DARK_SURFACE, ColorPalette.DARK_SURFACE]
        },
        "CTkToplevel": {
            "fg_color": [ColorPalette.DARK_SURFACE, ColorPalette.DARK_SURFACE]
        },
        "CTkFrame": {
            "corner_radius": 8,
            "border_width": 1,
            "fg_color": [ColorPalette.DARK_SURFACE_VARIANT, ColorPalette.DARK_SURFACE_VARIANT],
            "border_color": [ColorPalette.DARK_BORDER, ColorPalette.DARK_BORDER]
        },
        "CTkButton": {
            "corner_radius": 8,
            "border_width": 1,
            "fg_color": [ColorPalette.INFO, ColorPalette.INFO],
            "hover_color": ["#1E5F8C", "#1E5F8C"],
            "border_color": [ColorPalette.DARK_BORDER, ColorPalette.DARK_BORDER],
            "text_color": [ColorPalette.DARK_TEXT_PRIMARY, ColorPalette.DARK_TEXT_PRIMARY]
        },
        "CTkLabel": {
            "text_color": [ColorPalette.DARK_TEXT_PRIMARY, ColorPalette.DARK_TEXT_PRIMARY]
        },
        "CTkEntry": {
            "corner_radius": 8,
            "border_width": 1,
            "fg_color": [ColorPalette.DARK_SURFACE, ColorPalette.DARK_SURFACE],
            "border_color": [ColorPalette.DARK_BORDER, ColorPalette.DARK_BORDER],
            "text_color": [ColorPalette.DARK_TEXT_PRIMARY, ColorPalette.DARK_TEXT_PRIMARY]
        },
        "CTkProgressBar": {
            "corner_radius": 4,
            "border_width": 0,
            "fg_color": [ColorPalette.DARK_BORDER, ColorPalette.DARK_BORDER],
            "progress_color": [ColorPalette.SUCCESS, ColorPalette.SUCCESS]
        }
    }
    
    return dark_theme

def get_widget_colors(widget_type: str) -> dict:
    """Get color configuration for specific widget type"""
    theme = apply_dark_theme()
    return theme.get(widget_type, {})

🚨 PHASE 2: RISK RIBBON IMPLEMENTATION (Day 2)
Step 2.1: Risk Ribbon Component
File: src/ui/risk_ribbon.py
python"""
Risk Ribbon - Always visible risk monitoring and emergency controls
"""

import customtkinter as ctk
import tkinter as tk
from typing import Callable, Optional, Dict, Any
from datetime import datetime, timedelta
import threading
import time

from ..core.event_bus import event_bus
from ..core.state_manager import state_manager, RiskMetrics, ConnectivityStatus
from ..themes.colors import ColorPalette, get_risk_color, interpolate_color

class RiskMeter(ctk.CTkFrame):
    """Individual risk meter widget with progress bar and value display"""
    
    def __init__(self, master, title: str, **kwargs):
        super().__init__(master, **kwargs)
        
        self.title = title
        self.current_value = 0.0
        self.max_value = 100.0
        self.warning_threshold = 70.0
        self.danger_threshold = 90.0
        
        self.setup_ui()
    
    def setup_ui(self):
        """Setup meter UI components"""
        
        # Title label
        self.title_label = ctk.CTkLabel(
            self,
            text=self.title,
            font=ctk.CTkFont(family="Arial", size=11, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        self.title_label.pack(pady=(2, 0))
        
        # Progress bar
        self.progress_bar = ctk.CTkProgressBar(
            self,
            width=80,
            height=8,
            corner_radius=4,
            progress_color=ColorPalette.SUCCESS
        )
        self.progress_bar.pack(pady=(2, 2), padx=5, fill="x")
        
        # Value label
        self.value_label = ctk.CTkLabel(
            self,
            text="0.0%",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        self.value_label.pack()
        
        # Set initial progress
        self.progress_bar.set(0.0)
    
    def update_value(self, value: float, max_value: Optional[float] = None, 
                    warning_threshold: Optional[float] = None,
                    danger_threshold: Optional[float] = None):
        """Update meter value and appearance"""
        
        if max_value is not None:
            self.max_value = max_value
        if warning_threshold is not None:
            self.warning_threshold = warning_threshold
        if danger_threshold is not None:
            self.danger_threshold = danger_threshold
            
        self.current_value = value
        
        # Calculate progress ratio
        progress_ratio = min(abs(value) / self.max_value, 1.0) if self.max_value > 0 else 0.0
        
        # Update progress bar
        self.progress_bar.set(progress_ratio)
        
        # Update color based on thresholds
        percentage = (abs(value) / self.max_value * 100) if self.max_value > 0 else 0
        
        if percentage < self.warning_threshold:
            color = ColorPalette.SUCCESS
        elif percentage < self.danger_threshold:
            color = ColorPalette.WARNING
        else:
            color = ColorPalette.DANGER
            
        self.progress_bar.configure(progress_color=color)
        
        # Update value label
        self.value_label.configure(text=f"{value:.1f}%", text_color=color)
        
        # Animate if value changed significantly
        if hasattr(self, '_last_value') and abs(value - self._last_value) > 0.1:
            self.animate_change()
        
        self._last_value = value
    
    def animate_change(self):
        """Brief animation when value changes"""
        original_color = self.progress_bar.cget("progress_color")
        
        # Flash white briefly
        self.progress_bar.configure(progress_color="#FFFFFF")
        self.after(100, lambda: self.progress_bar.configure(progress_color=original_color))

class ConnectionStatusWidget(ctk.CTkFrame):
    """Connection status display with quality indicator"""
    
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        
        self.setup_ui()
        self.last_update = None
    
    def setup_ui(self):
        """Setup connection status UI"""
        
        # Title
        self.title_label = ctk.CTkLabel(
            self,
            text="DDE Status",
            font=ctk.CTkFont(family="Arial", size=11, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        self.title_label.pack(pady=(2, 0))
        
        # Status indicator (colored circle)
        self.status_indicator = ctk.CTkLabel(
            self,
            text="●",
            font=ctk.CTkFont(family="Arial", size=16, weight="bold"),
            text_color=ColorPalette.DANGER
        )
        self.status_indicator.pack()
        
        # Symbol count
        self.symbol_count_label = ctk.CTkLabel(
            self,
            text="0 symbols",
            font=ctk.CTkFont(family="Arial", size=9),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        self.symbol_count_label.pack()
        
        # Last update time
        self.last_update_label = ctk.CTkLabel(
            self,
            text="Never",
            font=ctk.CTkFont(family="Arial", size=8),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        self.last_update_label.pack()
    
    def update_status(self, connected: bool, symbol_count: int = 0, 
                     last_update: Optional[datetime] = None):
        """Update connection status display"""
        
        if connected:
            self.status_indicator.configure(text_color=ColorPalette.SUCCESS)
            self.symbol_count_label.configure(text=f"{symbol_count} symbols")
        else:
            self.status_indicator.configure(text_color=ColorPalette.DANGER)
            self.symbol_count_label.configure(text="Disconnected")
        
        # Update last update time
        if last_update:
            self.last_update = last_update
            time_diff = datetime.now() - last_update
            
            if time_diff.total_seconds() < 60:
                time_text = f"{int(time_diff.total_seconds())}s ago"
            elif time_diff.total_seconds() < 3600:
                time_text = f"{int(time_diff.total_seconds() / 60)}m ago"
            else:
                time_text = f"{int(time_diff.total_seconds() / 3600)}h ago"
                
            self.last_update_label.configure(text=time_text)
        else:
            self.last_update_label.configure(text="Never")

class EmergencyStopButton(ctk.CTkButton):
    """Emergency stop button with visual feedback"""
    
    def __init__(self, master, emergency_callback: Optional[Callable] = None, **kwargs):
        
        # Set default appearance
        default_kwargs = {
            "text": "🚨 EMERGENCY STOP",
            "font": ctk.CTkFont(family="Arial", size=14, weight="bold"),
            "fg_color": ColorPalette.DANGER,
            "hover_color": "#B71C1C",
            "width": 160,
            "height": 50,
            "corner_radius": 8,
            "border_width": 2,
            "border_color": "#FFFFFF"
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.emergency_callback = emergency_callback
        self.configure(command=self.handle_emergency_stop)
        
        self.is_armed = False
        self.is_stopping = False
        
        # Pulsing animation timer
        self.pulse_after_id = None
        
    def handle_emergency_stop(self):
        """Handle emergency stop button press"""
        
        if self.is_stopping:
            return
            
        self.is_stopping = True
        
        # Visual feedback
        self.configure(
            text="🔴 STOPPING...",
            state="disabled",
            fg_color="#666666"
        )
        
        # Publish emergency event
        event_bus.publish(
            "emergency_stop_triggered",
            {"timestamp": datetime.now().isoformat()},
            source="risk_ribbon"
        )
        
        # Call emergency callback if provided
        if self.emergency_callback:
            try:
                self.emergency_callback()
            except Exception as e:
                print(f"Emergency stop callback error: {e}")
        
        # Reset button after 3 seconds
        self.after(3000, self.reset_emergency_button)
    
    def reset_emergency_button(self):
        """Reset emergency button to normal state"""
        self.is_stopping = False
        self.configure(
            text="🚨 EMERGENCY STOP",
            state="normal",
            fg_color=ColorPalette.DANGER
        )
    
    def start_pulse_animation(self):
        """Start pulsing animation for critical alerts"""
        if not self.is_armed and not self.is_stopping:
            self.is_armed = True
            self._pulse_step(0)
    
    def stop_pulse_animation(self):
        """Stop pulsing animation"""
        self.is_armed = False
        if self.pulse_after_id:
            self.after_cancel(self.pulse_after_id)
            self.pulse_after_id = None
    
    def _pulse_step(self, step: int):
        """Single step of pulse animation"""
        if not self.is_armed:
            return
            
        # Calculate pulse intensity (0.0 to 1.0)
        intensity = abs(0.5 * (1 + time.sin(step * 0.2)))
        
        # Interpolate between normal and bright red
        color = interpolate_color(ColorPalette.DANGER, "#FF8888", intensity)
        self.configure(fg_color=color)
        
        # Schedule next pulse step
        self.pulse_after_id = self.after(50, lambda: self._pulse_step(step + 1))

class RiskRibbon(ctk.CTkFrame):
    """Main risk ribbon component - always visible at top of application"""
    
    def __init__(self, master, emergency_callback: Optional[Callable] = None, **kwargs):
        
        # Set default appearance
        default_kwargs = {
            "height": 70,
            "corner_radius": 0,
            "fg_color": ColorPalette.DARK_SURFACE_VARIANT,
            "border_width": 1,
            "border_color": ColorPalette.DARK_BORDER
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.emergency_callback = emergency_callback
        
        # Initialize components
        self.setup_ui()
        self.setup_event_handlers()
        
        # Start update loop
        self.start_update_loop()
    
    def setup_ui(self):
        """Setup risk ribbon UI components"""
        
        # Configure grid
        self.grid_columnconfigure((0, 1, 2, 3, 4), weight=1)
        self.grid_columnconfigure(5, weight=0)  # Emergency button column
        
        # Daily Drawdown Meter
        self.dd_meter = RiskMeter(self, title="Daily DD")
        self.dd_meter.grid(row=0, column=0, padx=8, pady=8, sticky="ew")
        
        # Portfolio Risk Meter
        self.portfolio_meter = RiskMeter(self, title="Portfolio Risk")
        self.portfolio_meter.grid(row=0, column=1, padx=8, pady=8, sticky="ew")
        
        # Correlation Meter
        self.correlation_meter = RiskMeter(self, title="Max Correlation")
        self.correlation_meter.grid(row=0, column=2, padx=8, pady=8, sticky="ew")
        
        # Session Cap Meter
        self.session_meter = RiskMeter(self, title="Session Cap")
        self.session_meter.grid(row=0, column=3, padx=8, pady=8, sticky="ew")
        
        # Connection Status
        self.connection_widget = ConnectionStatusWidget(self)
        self.connection_widget.grid(row=0, column=4, padx=8, pady=8, sticky="ew")
        
        # Emergency Stop Button
        self.emergency_button = EmergencyStopButton(
            self,
            emergency_callback=self.emergency_callback
        )
        self.emergency_button.grid(row=0, column=5, padx=12, pady=10)
        
        # Risk message label (hidden by default)
        self.risk_message_label = ctk.CTkLabel(
            self,
            text="",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.WARNING
        )
        # Will be shown when actions are blocked
    
    def setup_event_handlers(self):
        """Setup event handlers for state updates"""
        
        # Subscribe to relevant events
        event_bus.subscribe("risk_update", self._handle_risk_update)
        event_bus.subscribe("connectivity_update", self._handle_connectivity_update)
        event_bus.subscribe("action_blocked", self._handle_action_blocked)
        event_bus.subscribe("action_allowed", self._handle_action_allowed)
    
    def _handle_risk_update(self, event):
        """Handle risk metric updates"""
        data = event.data
        
        # Update daily drawdown meter
        dd_value = abs(data.get('daily_drawdown', 0.0))
        dd_limit = data.get('daily_limit', 2.0)
        self.dd_meter.update_value(dd_value, dd_limit, 70.0, 90.0)
        
        # Update portfolio risk meter
        portfolio_risk = data.get('portfolio_risk', 0.0)
        self.portfolio_meter.update_value(portfolio_risk, 5.0, 70.0, 90.0)
        
        # Update correlation meter
        correlation = data.get('max_correlation', 0.0) * 100  # Convert to percentage
        self.correlation_meter.update_value(correlation, 100.0, 60.0, 80.0)
        
        # Update session cap meter
        session_used = data.get('session_cap_used', 0.0)
        session_limit = data.get('session_cap_limit', 1.5)
        self.session_meter.update_value(session_used, session_limit, 70.0, 90.0)
        
        # Check if we should pulse emergency button
        self._check_critical_levels(data)
    
    def _handle_connectivity_update(self, event):
        """Handle connectivity status updates"""
        data = event.data
        
        self.connection_widget.update_status(
            connected=data.get('dde_connected', False),
            symbol_count=data.get('symbol_count', 0),
            last_update=data.get('last_update')
        )
    
    def _handle_action_blocked(self, event):
        """Handle action blocked events"""
        reason = event.data.get('reason', 'Unknown policy violation')
        
        # Show risk message
        self.risk_message_label.configure(text=f"⚠️ {reason}")
        self.risk_message_label.grid(row=1, column=0, columnspan=6, pady=(0, 5))
        
        # Start emergency button pulse
        self.emergency_button.start_pulse_animation()
        
        # Auto-hide message after 5 seconds
        self.after(5000, self._hide_risk_message)
    
    def _handle_action_allowed(self, event):
        """Handle action allowed events"""
        self._hide_risk_message()
        self.emergency_button.stop_pulse_animation()
    
    def _hide_risk_message(self):
        """Hide the risk message label"""
        self.risk_message_label.grid_remove()
    
    def _check_critical_levels(self, risk_data: Dict[str, Any]):
        """Check if any metrics are at critical levels"""
        
        critical_conditions = [
            abs(risk_data.get('daily_drawdown', 0.0)) >= risk_data.get('daily_limit', 2.0) * 0.95,
            risk_data.get('portfolio_risk', 0.0) >= 4.5,  # 90% of 5% max
            risk_data.get('max_correlation', 0.0) >= 0.68,  # 97% of 0.7 max
            risk_data.get('session_cap_used', 0.0) >= risk_data.get('session_cap_limit', 1.5) * 0.95
        ]
        
        if any(critical_conditions):
            self.emergency_button.start_pulse_animation()
        else:
            self.emergency_button.stop_pulse_animation()
    
    def start_update_loop(self):
        """Start the update loop for real-time display"""
        self.update_display()
        self.after(250, self.start_update_loop)  # Update every 250ms
    
    def update_display(self):
        """Update display based on current state"""
        
        # Get current state
        risk_metrics = state_manager.get_risk_metrics()
        connectivity = state_manager.get_connectivity_status()
        
        # Check if actions are allowed
        actions_allowed, reason = state_manager.is_action_allowed()
        
        if not actions_allowed:
            event_bus.publish(
                "action_blocked",
                {"reason": reason},
                source="risk_ribbon"
            )
        else:
            event_bus.publish(
                "action_allowed",
                {},
                source="risk_ribbon"
            )

# Example integration function
def integrate_risk_ribbon_with_main_window(main_window, emergency_callback=None):
    """
    Integration function to add risk ribbon to main window
    
    Args:
        main_window: Main application window (CTk or Tk)
        emergency_callback: Function to call on emergency stop
        
    Returns:
        RiskRibbon instance
    """
    
    risk_ribbon = RiskRibbon(main_window, emergency_callback=emergency_callback)
    risk_ribbon.pack(fill="x", side="top", padx=0, pady=0)
    
    return risk_ribbon
Step 2.2: Toast Manager Implementation
File: src/ui/toast_manager.py
python"""
Toast Notification System for HUEY_P GUI
Non-blocking notifications with auto-dismiss and queue management
"""

import customtkinter as ctk
import tkinter as tk
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import threading

from ..themes.colors import ColorPalette

class ToastType(Enum):
    INFO = "info"
    SUCCESS = "success"
    WARNING = "warning"
    DANGER = "danger"

@dataclass
class Toast:
    message: str
    toast_type: ToastType
    duration: float  # seconds
    timestamp: datetime
    action_text: Optional[str] = None
    action_callback: Optional[Callable] = None
    toast_id: Optional[str] = None

class ToastWidget(ctk.CTkFrame):
    """Individual toast notification widget"""
    
    def __init__(self, master, toast: Toast, dismiss_callback: Callable, **kwargs):
        
        # Set appearance based on toast type
        colors = self._get_toast_colors(toast.toast_type)
        
        default_kwargs = {
            "fg_color": colors["background"],
            "border_color": colors["border"],
            "border_width": 1,
            "corner_radius": 8,
            "width": 350,
            "height": 80
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.toast = toast
        self.dismiss_callback = dismiss_callback
        self.auto_dismiss_id = None
        
        self.setup_ui()
        self.start_auto_dismiss()
    
    def _get_toast_colors(self, toast_type: ToastType) -> Dict[str, str]:
        """Get colors for toast type"""
        color_map = {
            ToastType.INFO: {
                "background": "#1A2332",
                "border": ColorPalette.INFO,
                "text": ColorPalette.DARK_TEXT_PRIMARY,
                "icon": ColorPalette.INFO
            },
            ToastType.SUCCESS: {
                "background": "#1A2B1F",
                "border": ColorPalette.SUCCESS,
                "text": ColorPalette.DARK_TEXT_PRIMARY,
                "icon": ColorPalette.SUCCESS
            },
            ToastType.WARNING: {
                "background": "#2B2619",
                "border": ColorPalette.WARNING,
                "text": ColorPalette.DARK_TEXT_PRIMARY,
                "icon": ColorPalette.WARNING
            },
            ToastType.DANGER: {
                "background": "#2B1A1A",
                "border": ColorPalette.DANGER,
                "text": ColorPalette.DARK_TEXT_PRIMARY,
                "icon": ColorPalette.DANGER
            }
        }
        return color_map.get(toast_type, color_map[ToastType.INFO])
    
    def setup_ui(self):
        """Setup toast UI components"""
        
        colors = self._get_toast_colors(self.toast.toast_type)
        
        # Main content frame
        content_frame = ctk.CTkFrame(self, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=8, pady=8)
        
        # Top row: icon, message, close button
        top_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        top_frame.pack(fill="x", pady=(0, 4))
        
        # Icon
        icon_map = {
            ToastType.INFO: "ℹ️",
            ToastType.SUCCESS: "✅",
            ToastType.WARNING: "⚠️",
            ToastType.DANGER: "🚨"
        }
        
        icon_label = ctk.CTkLabel(
            top_frame,
            text=icon_map.get(self.toast.toast_type, "ℹ️"),
            font=ctk.CTkFont(family="Arial", size=16),
            width=24
        )
        icon_label.pack(side="left", padx=(0, 8))
        
        # Message
        message_label = ctk.CTkLabel(
            top_frame,
            text=self.toast.message,
            font=ctk.CTkFont(family="Arial", size=12),
            text_color=colors["text"],
            wraplength=250,
            justify="left"
        )
        message_label.pack(side="left", fill="x", expand=True)
        
        # Close button
        close_button = ctk.CTkButton(
            top_frame,
            text="✕",
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            width=24,
            height=24,
            fg_color="transparent",
            text_color=colors["text"],
            hover_color=colors["border"],
            command=self.dismiss
        )
        close_button.pack(side="right")
        
        # Bottom row: action button (if any) and timestamp
        bottom_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        bottom_frame.pack(fill="x")
        
        # Timestamp
        time_str = self.toast.timestamp.strftime("%H:%M:%S")
        timestamp_label = ctk.CTkLabel(
            bottom_frame,
            text=time_str,
            font=ctk.CTkFont(family="Arial", size=9),
            text_color=colors["text"],
            opacity=0.7
        )
        timestamp_label.pack(side="right")
        
        # Action button (if provided)
        if self.toast.action_text and self.toast.action_callback:
            action_button = ctk.CTkButton(
                bottom_frame,
                text=self.toast.action_text,
                font=ctk.CTkFont(family="Arial", size=10),
                height=24,
                fg_color=colors["border"],
                hover_color=colors["icon"],
                command=self._handle_action
            )
            action_button.pack(side="left")
    
    def _handle_action(self):
        """Handle action button click"""
        if self.toast.action_callback:
            try:
                self.toast.action_callback()
            except Exception as e:
                print(f"Toast action callback error: {e}")
        
        # Dismiss toast after action
        self.dismiss()
    
    def start_auto_dismiss(self):
        """Start auto-dismiss timer"""
        if self.toast.duration > 0:
            self.auto_dismiss_id = self.after(
                int(self.toast.duration * 1000),
                self.dismiss
            )
    
    def dismiss(self):
        """Dismiss this toast"""
        if self.auto_dismiss_id:
            self.after_cancel(self.auto_dismiss_id)
            self.auto_dismiss_id = None
        
        if self.dismiss_callback:
            self.dismiss_callback(self)

class ToastManager:
    """Manages toast notifications with queue and positioning"""
    
    def __init__(self, parent_window):
        self.parent_window = parent_window
        self.active_toasts: List[ToastWidget] = []
        self.toast_queue: List[Toast] = []
        self.max_visible_toasts = 5
        self.toast_spacing = 10
        self.position_offset_x = 20
        self.position_offset_y = 20
        
        # Thread lock for queue operations
        self._lock = threading.Lock()
        
        # Dedupe settings
        self.dedupe_window = 5.0  # seconds
        self.recent_messages: Dict[str, datetime] = {}
    
    def show_toast(self, message: str, toast_type: ToastType = ToastType.INFO,
                  duration: float = 4.0, action_text: Optional[str] = None,
                  action_callback: Optional[Callable] = None,
                  toast_id: Optional[str] = None) -> Optional[str]:
        """
        Show a toast notification
        
        Args:
            message: Toast message text
            toast_type: Type of toast (INFO, SUCCESS, WARNING, DANGER)
            duration: Auto-dismiss duration in seconds (0 = no auto-dismiss)
            action_text: Optional action button text
            action_callback: Optional action button callback
            toast_id: Optional unique ID for deduplication
            
        Returns:
            Toast ID if created, None if deduplicated
        """
        
        with self._lock:
            # Check for deduplication
            if self._is_duplicate_message(message):
                return None
            
            # Create toast
            toast = Toast(
                message=message,
                toast_type=toast_type,
                duration=duration,
                timestamp=datetime.now(),
                action_text=action_text,
                action_callback=action_callback,
                toast_id=toast_id or f"toast_{len(self.toast_queue)}"
            )
            
            # Add to queue
            self.toast_queue.append(toast)
            
            # Process queue
            self._process_queue()
            
            return toast.toast_id
    
    def _is_duplicate_message(self, message: str) -> bool:
        """Check if message was recently shown"""
        now = datetime.now()
        
        # Clean old entries
        cutoff = now - timedelta(seconds=self.dedupe_window)
        self.recent_messages = {
            msg: timestamp for msg, timestamp in self.recent_messages.items()
            if timestamp > cutoff
        }
        
        # Check for duplicate
        if message in self.recent_messages:
            return True
        
        # Record this message
        self.recent_messages[message] = now
        return False
    
    def _process_queue(self):
        """Process toast queue and display pending toasts"""
        
        # Remove dismissed toasts
        self.active_toasts = [toast for toast in self.active_toasts if toast.winfo_exists()]
        
        # Show toasts from queue if under limit
        while (len(self.active_toasts) < self.max_visible_toasts and 
               len(self.toast_queue) > 0):
            
            toast_data = self.toast_queue.pop(0)
            toast_widget = self._create_toast_widget(toast_data)
            
            if toast_widget:
                self.active_toasts.append(toast_widget)
                self._position_toast(toast_widget)
    
    def _create_toast_widget(self, toast: Toast) -> Optional[ToastWidget]:
        """Create toast widget"""
        try:
            toast_widget = ToastWidget(
                self.parent_window,
                toast,
                self._handle_toast_dismissed
            )
            return toast_widget
        except Exception as e:
            print(f"Failed to create toast widget: {e}")
            return None
    
    def _handle_toast_dismissed(self, toast_widget: ToastWidget):
        """Handle toast dismissal"""
        try:
            if toast_widget in self.active_toasts:
                self.active_toasts.remove(toast_widget)
                toast_widget.destroy()
                
            # Reposition remaining toasts
            self._reposition_toasts()
            
            # Process queue for any pending toasts
            self._process_queue()
            
        except Exception as e:
            print(f"Error handling toast dismissal: {e}")
    
    def _position_toast(self, toast_widget: ToastWidget):
        """Position toast widget on screen"""
        try:
            # Get parent window position and size
            parent_x = self.parent_window.winfo_x()
            parent_y = self.parent_window.winfo_y()
            parent_width = self.parent_window.winfo_width()
            parent_height = self.parent_window.winfo_height()
            
            # Calculate position (bottom-right corner)
            toast_width = 350
            toast_height = 80
            
            x = parent_x + parent_width - toast_width - self.position_offset_x
            y = (parent_y + parent_height - toast_height - self.position_offset_y -
                 (len(self.active_toasts) - 1) * (toast_height + self.toast_spacing))
            
            # Position toast
            toast_widget.place(x=x, y=y)
            
        except Exception as e:
            print(f"Error positioning toast: {e}")
    
    def _reposition_toasts(self):
        """Reposition all active toasts"""
        for i, toast_widget in enumerate(self.active_toasts):
            try:
                # Get parent window info
                parent_x = self.parent_window.winfo_x()
                parent_y = self.parent_window.winfo_y()
                parent_width = self.parent_window.winfo_width()
                parent_height = self.parent_window.winfo_height()
                
                # Calculate new position
                toast_width = 350
                toast_height = 80
                
                x = parent_x + parent_width - toast_width - self.position_offset_x
                y = (parent_y + parent_height - toast_height - self.position_offset_y -
                     i * (toast_height + self.toast_spacing))
                
                # Animate to new position
                toast_widget.place(x=x, y=y)
                
            except Exception as e:
                print(f"Error repositioning toast {i}: {e}")
    
    def clear_all_toasts(self):
        """Clear all active toasts and queue"""
        with self._lock:
            # Clear queue
            self.toast_queue.clear()
            
            # Dismiss all active toasts
            for toast_widget in self.active_toasts.copy():
                toast_widget.dismiss()
    
    def show_info(self, message: str, **kwargs):
        """Convenience method for info toasts"""
        return self.show_toast(message, ToastType.INFO, **kwargs)
    
    def show_success(self, message: str, **kwargs):
        """Convenience method for success toasts"""
        return self.show_toast(message, ToastType.SUCCESS, **kwargs)
    
    def show_warning(self, message: str, **kwargs):
        """Convenience method for warning toasts"""
        return self.show_toast(message, ToastType.WARNING, **kwargs)
    
    def show_danger(self, message: str, **kwargs):
        """Convenience method for danger toasts"""
        return self.show_toast(message, ToastType.DANGER, **kwargs)

# Global toast manager instance (to be initialized with main window)
toast_manager: Optional[ToastManager] = None

def initialize_toast_manager(parent_window):
    """Initialize global toast manager"""
    global toast_manager
    toast_manager = ToastManager(parent_window)
    return toast_manager

def show_toast(message: str, toast_type: ToastType = ToastType.INFO, **kwargs):
    """Global convenience function for showing toasts"""
    if toast_manager:
        return toast_manager.show_toast(message, toast_type, **kwargs)
    else:
        print(f"Toast Manager not initialized: {message}")
        return None

# Convenience functions
def show_info(message: str, **kwargs):
    return show_toast(message, ToastType.INFO, **kwargs)

def show_success(message: str, **kwargs):
    return show_toast(message, ToastType.SUCCESS, **kwargs)

def show_warning(message: str, **kwargs):
    return show_toast(message, ToastType.WARNING, **kwargs)

def show_danger(message: str, **kwargs):
    return show_toast(message, ToastType.DANGER, **kwargs)

📊 PHASE 3: STRENGTH & % CHANGE TAB (Day 3)
Step 3.1: Enhanced Table Components
File: src/ui/modern_widgets.py
python"""
Modern widget components for HUEY_P trading GUI
"""

import customtkinter as ctk
import tkinter as tk
from tkinter import ttk
from typing import Dict, List, Optional, Callable, Any, Union
import threading
from datetime import datetime

from ..themes.colors import ColorPalette, get_risk_color, get_currency_color

class SortableTreeview(ttk.Treeview):
    """Enhanced Treeview with sorting capabilities"""
    
    def __init__(self, master, columns: List[str], **kwargs):
        
        # Set default styling
        style = ttk.Style()
        style.theme_use("clam")
        
        # Configure dark theme colors
        style.configure(
            "Custom.Treeview",
            background=ColorPalette.DARK_SURFACE,
            foreground=ColorPalette.DARK_TEXT_PRIMARY,
            fieldbackground=ColorPalette.DARK_SURFACE,
            borderwidth=1,
            relief="solid"
        )
        
        style.configure(
            "Custom.Treeview.Heading",
            background=ColorPalette.DARK_SURFACE_VARIANT,
            foreground=ColorPalette.DARK_TEXT_PRIMARY,
            borderwidth=1,
            relief="solid"
        )
        
        # Map color for selected items
        style.map(
            "Custom.Treeview",
            background=[("selected", ColorPalette.INFO)],
            foreground=[("selected", "#FFFFFF")]
        )
        
        default_kwargs = {
            "columns": columns,
            "show": "headings",
            "style": "Custom.Treeview",
            "height": 10
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.columns = columns
        self.sort_columns: Dict[str, bool] = {}  # column -> ascending
        self.data_types: Dict[str, str] = {}  # column -> data type
        self.row_data: Dict[str, Dict[str, Any]] = {}  # item_id -> row_data
        
        self.setup_columns()
        self.setup_sorting()
    
    def setup_columns(self):
        """Setup column headers and widths"""
        
        # Default column widths
        default_widths = {
            0: 120,  # Name column (wider)
            1: 80,   # Data columns
            2: 80,
            3: 80,
            4: 80,
            5: 80,
            6: 80
        }
        
        for i, col in enumerate(self.columns):
            self.heading(col, text=col, anchor="center")
            self.column(
                col,
                width=default_widths.get(i, 80),
                anchor="e" if i > 0 else "w",  # Right-align data, left-align names
                minwidth=60
            )
    
    def setup_sorting(self):
        """Setup column sorting"""
        for col in self.columns:
            self.heading(col, command=lambda c=col: self.sort_by_column(c))
    
    def sort_by_column(self, column: str):
        """Sort table by specified column"""
        
        # Toggle sort direction
        ascending = not self.sort_columns.get(column, True)
        self.sort_columns[column] = ascending
        
        # Get all items and their values
        items = [(self.set(item, column), item) for item in self.get_children("")]
        
        # Determine data type and sort accordingly
        if items:
            sample_value = items[0][0]
            if self._is_number(sample_value):
                # Numeric sort
                items.sort(key=lambda x: self._parse_number(x[0]), reverse=not ascending)
            else:
                # String sort
                items.sort(key=lambda x: str(x[0]).lower(), reverse=not ascending)
        
        # Rearrange items
        for index, (value, item) in enumerate(items):
            self.move(item, "", index)
        
        # Update column header to show sort direction
        direction = "↑" if ascending else "↓"
        current_text = self.heading(column)["text"]
        if current_text.endswith("↑") or current_text.endswith("↓"):
            current_text = current_text[:-1]
        self.heading(column, text=f"{current_text}{direction}")
    
    def _is_number(self, value: str) -> bool:
        """Check if string represents a number"""
        try:
            self._parse_number(value)
            return True
        except (ValueError, TypeError):
            return False
    
    def _parse_number(self, value: str) -> float:
        """Parse number from string, handling percentage signs"""
        if isinstance(value, (int, float)):
            return float(value)
        
        # Remove common formatting
        clean_value = str(value).replace("%", "").replace(",", "").replace("$", "")
        return float(clean_value)
    
    def update_row(self, row_id: str, data: Dict[str, Any]):
        """Update or insert a row"""
        
        # Store raw data
        self.row_data[row_id] = data
        
        # Format values for display
        values = []
        for col in self.columns:
            value = data.get(col.lower().replace(" ", "_"), "")
            
            # Format numeric values
            if isinstance(value, (int, float)):
                if col.lower() != self.columns[0].lower():  # Not name column
                    formatted_value = f"{value:+.2f}%" if value != 0 else "0.00%"
                else:
                    formatted_value = str(value)
            else:
                formatted_value = str(value)
            
            values.append(formatted_value)
        
        # Check if item exists
        existing_items = {self.set(item, self.columns[0]): item for item in self.get_children("")}
        
        if values[0] in existing_items:
            # Update existing item
            item = existing_items[values[0]]
            for i, col in enumerate(self.columns):
                self.set(item, col, values[i])
        else:
            # Insert new item
            item = self.insert("", "end", values=values)
        
        # Apply color coding
        self._apply_row_colors(item, data)
    
    def _apply_row_colors(self, item: str, data: Dict[str, Any]):
        """Apply color coding to row based on data values"""
        
        # Color code based on average change
        changes = []
        for col in self.columns[1:]:  # Skip name column
            key = col.lower().replace(" ", "_")
            value = data.get(key, 0)
            if isinstance(value, (int, float)):
                changes.append(value)
        
        if changes:
            avg_change = sum(changes) / len(changes)
            
            if avg_change > 0.1:
                # Positive change - green tint
                self.item(item, tags=("positive",))
            elif avg_change < -0.1:
                # Negative change - red tint
                self.item(item, tags=("negative",))
            else:
                # Neutral - default
                self.item(item, tags=("neutral",))
        
        # Configure tag colors
        self.tag_configure("positive", background="#1A2B1F")
        self.tag_configure("negative", background="#2B1A1A")
        self.tag_configure("neutral", background=ColorPalette.DARK_SURFACE)
    
    def clear_all_rows(self):
        """Clear all rows from table"""
        for item in self.get_children(""):
            self.delete(item)
        self.row_data.clear()

class SparklineWidget(ctk.CTkCanvas):
    """Miniature sparkline chart widget"""
    
    def __init__(self, master, width: int = 60, height: int = 20, **kwargs):
        
        default_kwargs = {
            "width": width,
            "height": height,
            "bg": ColorPalette.DARK_SURFACE,
            "highlightthickness": 0
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.width = width
        self.height = height
        self.data_points: List[float] = []
        self.max_points = 20
        
    def add_data_point(self, value: float):
        """Add new data point and redraw"""
        self.data_points.append(value)
        
        # Keep only recent points
        if len(self.data_points) > self.max_points:
            self.data_points = self.data_points[-self.max_points:]
        
        self.redraw()
    
    def set_data(self, data_points: List[float]):
        """Set all data points at once"""
        self.data_points = data_points[-self.max_points:] if data_points else []
        self.redraw()
    
    def redraw(self):
        """Redraw sparkline"""
        self.delete("all")
        
        if len(self.data_points) < 2:
            return
        
        # Calculate scaling
        min_val = min(self.data_points)
        max_val = max(self.data_points)
        
        if max_val == min_val:
            # All values are the same
            y = self.height / 2
            for i in range(len(self.data_points) - 1):
                x1 = (i / (len(self.data_points) - 1)) * self.width
                x2 = ((i + 1) / (len(self.data_points) - 1)) * self.width
                self.create_line(x1, y, x2, y, fill=ColorPalette.INFO, width=1)
            return
        
        # Draw line segments
        for i in range(len(self.data_points) - 1):
            # Calculate positions
            x1 = (i / (len(self.data_points) - 1)) * self.width
            x2 = ((i + 1) / (len(self.data_points) - 1)) * self.width
            
            y1 = self.height - ((self.data_points[i] - min_val) / (max_val - min_val)) * self.height
            y2 = self.height - ((self.data_points[i + 1] - min_val) / (max_val - min_val)) * self.height
            
            # Color based on direction
            if self.data_points[i + 1] > self.data_points[i]:
                color = ColorPalette.SUCCESS
            elif self.data_points[i + 1] < self.data_points[i]:
                color = ColorPalette.DANGER
            else:
                color = ColorPalette.INFO
            
            self.create_line(x1, y1, x2, y2, fill=color, width=2)
        
        # Draw last point
        if self.data_points:
            last_x = self.width
            last_y = self.height - ((self.data_points[-1] - min_val) / (max_val - min_val)) * self.height
            self.create_oval(
                last_x - 2, last_y - 2, last_x + 2, last_y + 2,
                fill=ColorPalette.WARNING, outline=""
            )

class ColoredProgressBar(ctk.CTkProgressBar):
    """Progress bar with dynamic color based on value"""
    
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        
        self.warning_threshold = 0.7
        self.danger_threshold = 0.9
    
    def set_value_with_color(self, value: float, max_value: float = 1.0):
        """Set progress value and update color based on ratio"""
        
        ratio = min(value / max_value, 1.0) if max_value > 0 else 0.0
        self.set(ratio)
        
        # Update color based on ratio
        if ratio < self.warning_threshold:
            color = ColorPalette.SUCCESS
        elif ratio < self.danger_threshold:
            color = ColorPalette.WARNING
        else:
            color = ColorPalette.DANGER
        
        self.configure(progress_color=color)

class AdvancedTableWidget(ctk.CTkFrame):
    """Advanced table widget with sorting, filtering, and sparklines"""
    
    def __init__(self, master, title: str, columns: List[str], 
                 show_sparklines: bool = False, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE_VARIANT,
            "border_width": 1,
            "border_color": ColorPalette.DARK_BORDER,
            "corner_radius": 8
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.title = title
        self.columns = columns
        self.show_sparklines = show_sparklines
        
        # Data storage
        self.sparkline_data: Dict[str, List[float]] = {}
        self.update_lock = threading.Lock()
        
        self.setup_ui()
    
    def setup_ui(self):
        """Setup table UI components"""
        
        # Title bar
        title_frame = ctk.CTkFrame(self, fg_color="transparent", height=30)
        title_frame.pack(fill="x", padx=8, pady=(8, 0))
        title_frame.pack_propagate(False)
        
        title_label = ctk.CTkLabel(
            title_frame,
            text=self.title,
            font=ctk.CTkFont(family="Arial", size=14, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        title_label.pack(side="left", pady=4)
        
        # Filter/search entry
        self.search_entry = ctk.CTkEntry(
            title_frame,
            placeholder_text="Filter...",
            width=120,
            height=24
        )
        self.search_entry.pack(side="right", pady=4)
        self.search_entry.bind("<KeyRelease>", self._on_search_changed)
        
        # Table frame
        table_frame = ctk.CTkFrame(self, fg_color="transparent")
        table_frame.pack(fill="both", expand=True, padx=8, pady=8)
        
        # Create treeview with scrollbars
        tree_frame = ctk.CTkFrame(table_frame, fg_color="transparent")
        tree_frame.pack(fill="both", expand=True)
        
        # Treeview
        self.tree = SortableTreeview(tree_frame, columns=self.columns)
        
        # Scrollbars
        v_scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=self.tree.yview)
        h_scrollbar = ttk.Scrollbar(tree_frame, orient="horizontal", command=self.tree.xview)
        
        self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Pack scrollbars and tree
        self.tree.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew")
        
        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)
        
        # Status bar
        status_frame = ctk.CTkFrame(self, fg_color="transparent", height=25)
        status_frame.pack(fill="x", padx=8, pady=(0, 8))
        status_frame.pack_propagate(False)
        
        self.status_label = ctk.CTkLabel(
            status_frame,
            text="0 items",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        self.status_label.pack(side="left", pady=2)
        
        self.last_update_label = ctk.CTkLabel(
            status_frame,
            text="Never updated",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        self.last_update_label.pack(side="right", pady=2)
    
    def _on_search_changed(self, event):
        """Handle search text changes"""
        search_text = self.search_entry.get().lower()
        self._apply_filter(search_text)
    
    def _apply_filter(self, search_text: str):
        """Apply search filter to table"""
        
        for item in self.tree.get_children(""):
            # Get first column value (name)
            name = self.tree.set(item, self.columns[0]).lower()
            
            if search_text in name:
                # Show item
                self.tree.reattach(item, "", "end")
            else:
                # Hide item
                self.tree.detach(item)
    
    def update_rows(self, rows: List[Dict[str, Any]]):
        """Update table with new data"""
        
        with self.update_lock:
            # Clear and update
            self.tree.clear_all_rows()
            
            for row in rows:
                name = row.get("name", "")
                if name:
                    self.tree.update_row(name, row)
                    
                    # Update sparkline data if enabled
                    if self.show_sparklines and name in self.sparkline_data:
                        # Add current value to sparkline history
                        current_values = [row.get(col.lower().replace(" ", "_"), 0) 
                                        for col in self.columns[1:]]
                        if current_values:
                            avg_value = sum(current_values) / len(current_values)
                            if name not in self.sparkline_data:
                                self.sparkline_data[name] = []
                            self.sparkline_data[name].append(avg_value)
            
            # Update status
            self.status_label.configure(text=f"{len(rows)} items")
            self.last_update_label.configure(text=f"Updated: {datetime.now().strftime('%H:%M:%S')}")
    
    def add_sparkline_column(self):
        """Add sparkline column to table (call before setup_ui)"""
        if "Trend" not in self.columns:
            self.columns.append("Trend")
            self.show_sparklines = True

class HeatmapWidget(ctk.CTkFrame):
    """Heatmap visualization for currency strength data"""
    
    def __init__(self, master, currencies: List[str], timeframes: List[str], **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE_VARIANT,
            "border_width": 1,
            "border_color": ColorPalette.DARK_BORDER,
            "corner_radius": 8
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.currencies = currencies
        self.timeframes = timeframes
        self.cell_size = 40
        self.data: Dict[str, Dict[str, float]] = {}
        
        self.setup_ui()
    
    def setup_ui(self):
        """Setup heatmap UI"""
        
        # Title
        title_label = ctk.CTkLabel(
            self,
            text="Currency Strength Heatmap",
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        title_label.pack(pady=8)
        
        # Heatmap canvas
        canvas_width = len(self.timeframes) * self.cell_size + 80  # Extra space for labels
        canvas_height = len(self.currencies) * self.cell_size + 40
        
        self.canvas = ctk.CTkCanvas(
            self,
            width=canvas_width,
            height=canvas_height,
            bg=ColorPalette.DARK_SURFACE,
            highlightthickness=0
        )
        self.canvas.pack(padx=8, pady=8)
        
        # Draw grid
        self.draw_grid()
    
    def draw_grid(self):
        """Draw heatmap grid structure"""
        
        # Clear canvas
        self.canvas.delete("all")
        
        # Draw timeframe headers
        for i, timeframe in enumerate(self.timeframes):
            x = 60 + i * self.cell_size + self.cell_size / 2
            y = 20
            
            self.canvas.create_text(
                x, y,
                text=timeframe,
                fill=ColorPalette.DARK_TEXT_PRIMARY,
                font=("Arial", 10, "bold")
            )
        
        # Draw currency labels and cells
        for i, currency in enumerate(self.currencies):
            y = 40 + i * self.cell_size + self.cell_size / 2
            
            # Currency label
            self.canvas.create_text(
                30, y,
                text=currency,
                fill=ColorPalette.DARK_TEXT_PRIMARY,
                font=("Arial", 10, "bold")
            )
            
            # Draw cells for this currency
            for j, timeframe in enumerate(self.timeframes):
                x = 60 + j * self.cell_size
                
                # Cell rectangle
                self.canvas.create_rectangle(
                    x, 40 + i * self.cell_size,
                    x + self.cell_size, 40 + (i + 1) * self.cell_size,
                    fill=ColorPalette.DARK_SURFACE,
                    outline=ColorPalette.DARK_BORDER,
                    tags=f"cell_{currency}_{timeframe}"
                )
                
                # Cell text (placeholder)
                self.canvas.create_text(
                    x + self.cell_size / 2,
                    40 + i * self.cell_size + self.cell_size / 2,
                    text="0.0",
                    fill=ColorPalette.DARK_TEXT_SECONDARY,
                    font=("Arial", 9),
                    tags=f"text_{currency}_{timeframe}"
                )
    
    def update_data(self, data: Dict[str, Dict[str, float]]):
        """Update heatmap with new data"""
        
        self.data = data
        
        # Find min/max values for color scaling
        all_values = []
        for currency_data in data.values():
            all_values.extend(currency_data.values())
        
        if not all_values:
            return
        
        min_val = min(all_values)
        max_val = max(all_values)
        
        # Update cells
        for i, currency in enumerate(self.currencies):
            for j, timeframe in enumerate(self.timeframes):
                
                value = data.get(currency, {}).get(timeframe, 0.0)
                
                # Calculate color based on value
                if max_val != min_val:
                    ratio = (value - min_val) / (max_val - min_val)
                else:
                    ratio = 0.5
                
                # Color scale: red -> neutral -> green
                if ratio < 0.5:
                    # Red to neutral
                    color = self._interpolate_color("#FF4444", "#666666", ratio * 2)
                else:
                    # Neutral to green
                    color = self._interpolate_color("#666666", "#00FF88", (ratio - 0.5) * 2)
                
                # Update cell color
                cell_tag = f"cell_{currency}_{timeframe}"
                self.canvas.itemconfig(cell_tag, fill=color)
                
                # Update cell text
                text_tag = f"text_{currency}_{timeframe}"
                self.canvas.itemconfig(text_tag, text=f"{value:.1f}")
                
                # Text color based on background
                text_color = "#FFFFFF" if ratio < 0.3 or ratio > 0.7 else "#000000"
                self.canvas.itemconfig(text_tag, fill=text_color)
    
    def _interpolate_color(self, color1: str, color2: str, ratio: float) -> str:
        """Interpolate between two hex colors"""
        # Convert hex to RGB
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        
        def rgb_to_hex(rgb):
            return f"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}"
        
        rgb1 = hex_to_rgb(color1)
        rgb2 = hex_to_rgb(color2)
        
        # Interpolate each channel
        r = int(rgb1[0] + (rgb2[0] - rgb1[0]) * ratio)
        g = int(rgb1[1] + (rgb2[1] - rgb1[1]) * ratio)
        b = int(rgb1[2] + (rgb2[2] - rgb1[2]) * ratio)
        
        return rgb_to_hex((r, g, b))
Step 3.2: Strength & % Change Tab Implementation
File: src/ui/strength_tab.py
python"""
Strength & % Change Tab Implementation
Enhanced with sorting, sparklines, heatmap, and oscillator drill-down
"""

import customtkinter as ctk
import tkinter as tk
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime
import threading
import math

from ..core.event_bus import event_bus
from ..core.state_manager import state_manager
from ..themes.colors import ColorPalette, get_currency_color
from .modern_widgets import AdvancedTableWidget, HeatmapWidget, SparklineWidget
from .toast_manager import show_info, show_warning

class OscillatorDrilldownWindow(ctk.CTkToplevel):
    """Drill-down window for currency strength oscillators"""
    
    def __init__(self, master, currency: str, oscillator_type: str):
        super().__init__(master)
        
        self.currency = currency
        self.oscillator_type = oscillator_type
        
        # Window configuration
        self.title(f"{currency} {oscillator_type} Analysis")
        self.geometry("600x400")
        self.configure(fg_color=ColorPalette.DARK_SURFACE)
        
        # Make window modal
        self.transient(master)
        self.grab_set()
        
        self.setup_ui()
        self.load_oscillator_data()
    
    def setup_ui(self):
        """Setup oscillator drill-down UI"""
        
        # Header
        header_frame = ctk.CTkFrame(self, fg_color="transparent")
        header_frame.pack(fill="x", padx=20, pady=20)
        
        title_label = ctk.CTkLabel(
            header_frame,
            text=f"{self.currency} {self.oscillator_type}",
            font=ctk.CTkFont(family="Arial", size=18, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        title_label.pack(side="left")
        
        # Close button
        close_button = ctk.CTkButton(
            header_frame,
            text="✕",
            width=30,
            height=30,
            command=self.destroy
        )
        close_button.pack(side="right")
        
        # Main content frame
        content_frame = ctk.CTkFrame(self)
        content_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))
        
        # Configuration panel
        config_frame = ctk.CTkFrame(content_frame)
        config_frame.pack(fill="x", padx=10, pady=10)
        
        # Oscillator parameters
        params_frame = ctk.CTkFrame(config_frame, fg_color="transparent")
        params_frame.pack(fill="x", padx=10, pady=10)
        
        # Period setting
        ctk.CTkLabel(
            params_frame,
            text="Period:",
            font=ctk.CTkFont(family="Arial", size=12)
        ).pack(side="left", padx=(0, 10))
        
        self.period_slider = ctk.CTkSlider(
            params_frame,
            from_=5,
            to=50,
            number_of_steps=45,
            width=200
        )
        self.period_slider.pack(side="left", padx=(0, 10))
        self.period_slider.set(14)  # Default RSI period
        
        self.period_label = ctk.CTkLabel(
            params_frame,
            text="14",
            font=ctk.CTkFont(family="Arial", size=12)
        )
        self.period_label.pack(side="left", padx=(0, 20))
        
        # Bind slider to update label
        self.period_slider.configure(command=self.on_period_changed)
        
        # Threshold settings (for RSI/Stochastic)
        if self.oscillator_type in ["StrengthRSI", "StrengthStochastic"]:
            ctk.CTkLabel(
                params_frame,
                text="OB/OS:",
                font=ctk.CTkFont(family="Arial", size=12)
            ).pack(side="left", padx=(20, 10))
            
            self.ob_entry = ctk.CTkEntry(
                params_frame,
                width=60,
                placeholder_text="70"
            )
            self.ob_entry.pack(side="left", padx=(0, 5))
            
            ctk.CTkLabel(
                params_frame,
                text="/",
                font=ctk.CTkFont(family="Arial", size=12)
            ).pack(side="left", padx=(0, 5))
            
            self.os_entry = ctk.CTkEntry(
                params_frame,
                width=60,
                placeholder_text="30"
            )
            self.os_entry.pack(side="left", padx=(0, 10))
        
        # Chart area (placeholder for now)
        chart_frame = ctk.CTkFrame(content_frame)
        chart_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Chart canvas
        self.chart_canvas = ctk.CTkCanvas(
            chart_frame,
            width=560,
            height=250,
            bg=ColorPalette.DARK_SURFACE,
            highlightthickness=0
        )
        self.chart_canvas.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Values display
        values_frame = ctk.CTkFrame(content_frame)
        values_frame.pack(fill="x", padx=10, pady=10)
        
        # Current value
        self.current_value_label = ctk.CTkLabel(
            values_frame,
            text="Current Value: --",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        self.current_value_label.pack(side="left", padx=10, pady=10)
        
        # Signal status
        self.signal_label = ctk.CTkLabel(
            values_frame,
            text="Signal: Neutral",
            font=ctk.CTkFont(family="Arial", size=14),
            text_color=ColorPalette.INFO
        )
        self.signal_label.pack(side="right", padx=10, pady=10)
    
    def on_period_changed(self, value):
        """Handle period slider changes"""
        period = int(value)
        self.period_label.configure(text=str(period))
        
        # Recalculate oscillator with new period
        self.calculate_oscillator(period)
    
    def load_oscillator_data(self):
        """Load and display oscillator data"""
        
        # Get currency strength history
        market_data = state_manager.get_market_data()
        currency_strength = market_data.currency_strength.get(self.currency, {})
        
        if not currency_strength:
            self.current_value_label.configure(text="Current Value: No data")
            return
        
        # Calculate oscillator with default period
        self.calculate_oscillator(14)
    
    def calculate_oscillator(self, period: int):
        """Calculate oscillator values"""
        
        try:
            # Get strength data for this currency
            market_data = state_manager.get_market_data()
            
            # Simulate historical data (replace with actual historical data)
            historical_values = self._generate_sample_data()
            
            if self.oscillator_type == "StrengthRSI":
                current_value = self._calculate_rsi(historical_values, period)
                signal = self._get_rsi_signal(current_value)
            elif self.oscillator_type == "StrengthStochastic":
                current_value = self._calculate_stochastic(historical_values, period)
                signal = self._get_stochastic_signal(current_value)
            elif self.oscillator_type == "StrengthZScore":
                current_value = self._calculate_zscore(historical_values, period)
                signal = self._get_zscore_signal(current_value)
            else:
                current_value = 0.0
                signal = "Unknown"
            
            # Update display
            self.current_value_label.configure(text=f"Current Value: {current_value:.2f}")
            
            # Update signal with color
            signal_colors = {
                "Overbought": ColorPalette.DANGER,
                "Oversold": ColorPalette.SUCCESS,
                "Strong": ColorPalette.SUCCESS,
                "Weak": ColorPalette.DANGER,
                "Neutral": ColorPalette.INFO
            }
            
            self.signal_label.configureRetryDContinueEditPlotted next steps for strength tab implementation strategy.The user wants me to continue with the implementation guide. I was in the middle of implementing the OscillatorDrilldownWindow class in the strength_tab.py file. I need to continue from where I left off - I was in the middle of the calculate_oscillator method, specifically updating the signal label configuration.
Let me continue with the rest of that method and complete the strength tab implementation, then continue with the remaining phases according to the comprehensive implementation guide structure I established.python            self.signal_label.configure(
                text=f"Signal: {signal}",
                text_color=signal_colors.get(signal, ColorPalette.INFO)
            )
            
            # Draw chart
            self.draw_oscillator_chart(historical_values, current_value, period)
            
        except Exception as e:
            print(f"Error calculating oscillator: {e}")
            self.current_value_label.configure(text="Current Value: Error")
    
    def _generate_sample_data(self) -> List[float]:
        """Generate sample historical data (replace with actual data source)"""
        import random
        import math
        
        # Generate 100 data points with some trend and noise
        base_value = 0.0
        values = []
        
        for i in range(100):
            # Add trend and noise
            trend = math.sin(i * 0.1) * 0.5
            noise = random.uniform(-0.2, 0.2)
            value = base_value + trend + noise
            values.append(value)
            base_value = value * 0.95  # Slight mean reversion
        
        return values
    
    def _calculate_rsi(self, values: List[float], period: int) -> float:
        """Calculate RSI for strength values"""
        if len(values) < period + 1:
            return 50.0
        
        gains = []
        losses = []
        
        for i in range(1, len(values)):
            change = values[i] - values[i-1]
            if change > 0:
                gains.append(change)
                losses.append(0)
            else:
                gains.append(0)
                losses.append(abs(change))
        
        # Calculate average gains and losses
        avg_gain = sum(gains[-period:]) / period
        avg_loss = sum(losses[-period:]) / period
        
        if avg_loss == 0:
            return 100.0
        
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi
    
    def _calculate_stochastic(self, values: List[float], period: int) -> float:
        """Calculate Stochastic for strength values"""
        if len(values) < period:
            return 50.0
        
        recent_values = values[-period:]
        high = max(recent_values)
        low = min(recent_values)
        current = values[-1]
        
        if high == low:
            return 50.0
        
        stoch = ((current - low) / (high - low)) * 100
        return stoch
    
    def _calculate_zscore(self, values: List[float], period: int) -> float:
        """Calculate Z-Score for strength values"""
        if len(values) < period:
            return 0.0
        
        recent_values = values[-period:]
        mean = sum(recent_values) / len(recent_values)
        
        variance = sum((x - mean) ** 2 for x in recent_values) / len(recent_values)
        std_dev = math.sqrt(variance)
        
        if std_dev == 0:
            return 0.0
        
        current = values[-1]
        zscore = (current - mean) / std_dev
        
        return zscore
    
    def _get_rsi_signal(self, rsi_value: float) -> str:
        """Get RSI signal interpretation"""
        ob_threshold = float(self.ob_entry.get() or "70")
        os_threshold = float(self.os_entry.get() or "30")
        
        if rsi_value >= ob_threshold:
            return "Overbought"
        elif rsi_value <= os_threshold:
            return "Oversold"
        else:
            return "Neutral"
    
    def _get_stochastic_signal(self, stoch_value: float) -> str:
        """Get Stochastic signal interpretation"""
        ob_threshold = float(self.ob_entry.get() or "80")
        os_threshold = float(self.os_entry.get() or "20")
        
        if stoch_value >= ob_threshold:
            return "Overbought"
        elif stoch_value <= os_threshold:
            return "Oversold"
        else:
            return "Neutral"
    
    def _get_zscore_signal(self, zscore_value: float) -> str:
        """Get Z-Score signal interpretation"""
        if zscore_value >= 2.0:
            return "Strong"
        elif zscore_value <= -2.0:
            return "Weak"
        elif abs(zscore_value) <= 1.0:
            return "Neutral"
        else:
            return "Moderate"
    
    def draw_oscillator_chart(self, historical_values: List[float], current_value: float, period: int):
        """Draw oscillator chart on canvas"""
        
        self.chart_canvas.delete("all")
        
        if len(historical_values) < 2:
            return
        
        # Calculate oscillator values for chart
        chart_values = []
        
        for i in range(period, len(historical_values)):
            data_slice = historical_values[max(0, i-period):i+1]
            
            if self.oscillator_type == "StrengthRSI":
                value = self._calculate_rsi(data_slice, period)
            elif self.oscillator_type == "StrengthStochastic":
                value = self._calculate_stochastic(data_slice, period)
            elif self.oscillator_type == "StrengthZScore":
                value = self._calculate_zscore(data_slice, period)
            else:
                value = 0.0
            
            chart_values.append(value)
        
        if not chart_values:
            return
        
        # Chart dimensions
        chart_width = self.chart_canvas.winfo_width() - 40
        chart_height = self.chart_canvas.winfo_height() - 40
        
        if chart_width <= 0 or chart_height <= 0:
            return
        
        # Determine Y-axis range based on oscillator type
        if self.oscillator_type in ["StrengthRSI", "StrengthStochastic"]:
            min_y, max_y = 0, 100
            
            # Draw threshold lines
            ob_threshold = float(self.ob_entry.get() or ("70" if self.oscillator_type == "StrengthRSI" else "80"))
            os_threshold = float(self.os_entry.get() or ("30" if self.oscillator_type == "StrengthRSI" else "20"))
            
            # Overbought line
            ob_y = 20 + (1 - ob_threshold / 100) * chart_height
            self.chart_canvas.create_line(
                20, ob_y, 20 + chart_width, ob_y,
                fill=ColorPalette.DANGER, dash=(5, 5), width=1
            )
            
            # Oversold line
            os_y = 20 + (1 - os_threshold / 100) * chart_height
            self.chart_canvas.create_line(
                20, os_y, 20 + chart_width, os_y,
                fill=ColorPalette.SUCCESS, dash=(5, 5), width=1
            )
            
            # Middle line (50)
            mid_y = 20 + chart_height / 2
            self.chart_canvas.create_line(
                20, mid_y, 20 + chart_width, mid_y,
                fill=ColorPalette.DARK_TEXT_SECONDARY, dash=(2, 2), width=1
            )
            
        else:  # Z-Score
            min_y = min(chart_values) - 0.5
            max_y = max(chart_values) + 0.5
            
            # Draw Z-Score threshold lines
            for threshold, color in [(-2, ColorPalette.SUCCESS), (-1, ColorPalette.WARNING), 
                                   (0, ColorPalette.DARK_TEXT_SECONDARY), 
                                   (1, ColorPalette.WARNING), (2, ColorPalette.DANGER)]:
                if min_y <= threshold <= max_y:
                    y = 20 + (1 - (threshold - min_y) / (max_y - min_y)) * chart_height
                    dash_style = (2, 2) if threshold == 0 else (5, 5)
                    self.chart_canvas.create_line(
                        20, y, 20 + chart_width, y,
                        fill=color, dash=dash_style, width=1
                    )
        
        # Draw oscillator line
        for i in range(len(chart_values) - 1):
            x1 = 20 + (i / (len(chart_values) - 1)) * chart_width
            x2 = 20 + ((i + 1) / (len(chart_values) - 1)) * chart_width
            
            y1 = 20 + (1 - (chart_values[i] - min_y) / (max_y - min_y)) * chart_height
            y2 = 20 + (1 - (chart_values[i + 1] - min_y) / (max_y - min_y)) * chart_height
            
            # Color based on value
            if self.oscillator_type in ["StrengthRSI", "StrengthStochastic"]:
                ob_threshold = float(self.ob_entry.get() or ("70" if self.oscillator_type == "StrengthRSI" else "80"))
                os_threshold = float(self.os_entry.get() or ("30" if self.oscillator_type == "StrengthRSI" else "20"))
                
                if chart_values[i + 1] >= ob_threshold:
                    color = ColorPalette.DANGER
                elif chart_values[i + 1] <= os_threshold:
                    color = ColorPalette.SUCCESS
                else:
                    color = ColorPalette.INFO
            else:  # Z-Score
                if chart_values[i + 1] >= 2:
                    color = ColorPalette.DANGER
                elif chart_values[i + 1] <= -2:
                    color = ColorPalette.SUCCESS
                else:
                    color = ColorPalette.INFO
            
            self.chart_canvas.create_line(x1, y1, x2, y2, fill=color, width=2)
        
        # Draw current value point
        if chart_values:
            last_x = 20 + chart_width
            last_y = 20 + (1 - (chart_values[-1] - min_y) / (max_y - min_y)) * chart_height
            
            self.chart_canvas.create_oval(
                last_x - 4, last_y - 4, last_x + 4, last_y + 4,
                fill=ColorPalette.WARNING, outline=ColorPalette.DARK_TEXT_PRIMARY, width=2
            )

class StrengthAndPercentChangeTab(ctk.CTkFrame):
    """Main Strength & % Change Tab with enhanced features"""
    
    def __init__(self, master, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE,
            "corner_radius": 0
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        # Configuration
        self.timeframes = ["15m", "1h", "4h", "8h", "12h", "24h"]
        self.currencies = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "CAD", "NZD"]
        
        # Data storage
        self.pair_data: Dict[str, Dict[str, float]] = {}
        self.currency_strength_data: Dict[str, Dict[str, float]] = {}
        self.update_lock = threading.Lock()
        
        # UI update control
        self.last_update = datetime.now()
        self.update_interval = 1.0  # seconds
        
        self.setup_ui()
        self.setup_event_handlers()
        self.start_update_loop()
    
    def setup_ui(self):
        """Setup strength tab UI components"""
        
        # Main container with paned window for resizable sections
        main_paned = ctk.CTkFrame(self, fg_color="transparent")
        main_paned.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Top section: Tables side by side
        tables_frame = ctk.CTkFrame(main_paned, fg_color="transparent")
        tables_frame.pack(fill="both", expand=True)
        
        # Configure grid for equal distribution
        tables_frame.grid_columnconfigure(0, weight=1)
        tables_frame.grid_columnconfigure(1, weight=1)
        tables_frame.grid_rowconfigure(0, weight=1)
        
        # Left: Pair % Change Table
        pair_columns = ["Pair"] + self.timeframes
        self.pair_table = AdvancedTableWidget(
            tables_frame,
            title="Currency Pair % Changes",
            columns=pair_columns,
            show_sparklines=True
        )
        self.pair_table.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        
        # Right: Currency Strength Table  
        strength_columns = ["Currency"] + self.timeframes
        self.strength_table = AdvancedTableWidget(
            tables_frame,
            title="Currency Strength",
            columns=strength_columns,
            show_sparklines=True
        )
        self.strength_table.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        
        # Add click handlers for oscillator drill-down
        self.strength_table.tree.bind("<Double-1>", self.on_currency_double_click)
        
        # Bottom section: Controls and Heatmap
        bottom_frame = ctk.CTkFrame(main_paned, fg_color="transparent")
        bottom_frame.pack(fill="x", pady=(10, 0))
        
        # Controls panel
        controls_frame = ctk.CTkFrame(bottom_frame)
        controls_frame.pack(fill="x", pady=(0, 10))
        
        # Control buttons
        button_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        button_frame.pack(fill="x", padx=10, pady=10)
        
        # Refresh button
        refresh_button = ctk.CTkButton(
            button_frame,
            text="🔄 Refresh Data",
            font=ctk.CTkFont(family="Arial", size=12),
            width=120,
            command=self.force_refresh
        )
        refresh_button.pack(side="left", padx=(0, 10))
        
        # Export button
        export_button = ctk.CTkButton(
            button_frame,
            text="📊 Export CSV",
            font=ctk.CTkFont(family="Arial", size=12),
            width=120,
            command=self.export_data
        )
        export_button.pack(side="left", padx=(0, 10))
        
        # Settings button
        settings_button = ctk.CTkButton(
            button_frame,
            text="⚙️ Settings",
            font=ctk.CTkFont(family="Arial", size=12),
            width=120,
            command=self.show_settings
        )
        settings_button.pack(side="left", padx=(0, 10))
        
        # Update frequency control
        frequency_frame = ctk.CTkFrame(button_frame, fg_color="transparent")
        frequency_frame.pack(side="right")
        
        ctk.CTkLabel(
            frequency_frame,
            text="Update Rate:",
            font=ctk.CTkFont(family="Arial", size=12)
        ).pack(side="left", padx=(0, 5))
        
        self.frequency_slider = ctk.CTkSlider(
            frequency_frame,
            from_=0.5,
            to=5.0,
            number_of_steps=9,
            width=100
        )
        self.frequency_slider.pack(side="left", padx=(0, 5))
        self.frequency_slider.set(1.0)
        self.frequency_slider.configure(command=self.on_frequency_changed)
        
        self.frequency_label = ctk.CTkLabel(
            frequency_frame,
            text="1.0s",
            font=ctk.CTkFont(family="Arial", size=12)
        )
        self.frequency_label.pack(side="left")
        
        # Heatmap section (collapsible)
        heatmap_frame = ctk.CTkFrame(bottom_frame)
        heatmap_frame.pack(fill="x")
        
        # Heatmap header with toggle
        heatmap_header = ctk.CTkFrame(heatmap_frame, fg_color="transparent", height=35)
        heatmap_header.pack(fill="x", padx=10, pady=(10, 0))
        heatmap_header.pack_propagate(False)
        
        self.heatmap_toggle = ctk.CTkButton(
            heatmap_header,
            text="📊 Show Currency Strength Heatmap",
            font=ctk.CTkFont(family="Arial", size=12),
            fg_color="transparent",
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            hover_color=ColorPalette.DARK_SURFACE_VARIANT,
            anchor="w",
            command=self.toggle_heatmap
        )
        self.heatmap_toggle.pack(fill="x")
        
        # Heatmap content (initially hidden)
        self.heatmap_content = ctk.CTkFrame(heatmap_frame)
        # Don't pack initially - will be shown when toggled
        
        self.heatmap_widget = HeatmapWidget(
            self.heatmap_content,
            currencies=self.currencies,
            timeframes=self.timeframes
        )
        self.heatmap_widget.pack(fill="both", expand=True, padx=10, pady=10)
        
        self.heatmap_visible = False
    
    def setup_event_handlers(self):
        """Setup event handlers for data updates"""
        
        # Subscribe to relevant events
        event_bus.subscribe("market_data_update", self._handle_market_data_update)
        event_bus.subscribe("currency_strength_update", self._handle_currency_strength_update)
    
    def _handle_market_data_update(self, event):
        """Handle market data updates"""
        data = event.data
        
        with self.update_lock:
            # Update pair data
            if 'symbols' in data:
                self.pair_data.update(data['symbols'])
            
            # Update currency strength data
            if 'currency_strength' in data:
                self.currency_strength_data.update(data['currency_strength'])
    
    def _handle_currency_strength_update(self, event):
        """Handle currency strength specific updates"""
        data = event.data
        
        with self.update_lock:
            self.currency_strength_data.update(data)
    
    def on_frequency_changed(self, value):
        """Handle update frequency changes"""
        self.update_interval = float(value)
        self.frequency_label.configure(text=f"{value:.1f}s")
    
    def on_currency_double_click(self, event):
        """Handle double-click on currency for oscillator drill-down"""
        
        # Get selected item
        item = self.strength_table.tree.selection()[0] if self.strength_table.tree.selection() else None
        if not item:
            return
        
        # Get currency name
        currency = self.strength_table.tree.set(item, "Currency")
        
        # Show oscillator selection menu
        self.show_oscillator_menu(currency, event)
    
    def show_oscillator_menu(self, currency: str, event):
        """Show oscillator selection menu"""
        
        # Create context menu
        menu = tk.Menu(self, tearoff=0)
        menu.configure(
            bg=ColorPalette.DARK_SURFACE_VARIANT,
            fg=ColorPalette.DARK_TEXT_PRIMARY,
            activebackground=ColorPalette.INFO,
            activeforeground="#FFFFFF"
        )
        
        oscillators = [
            ("Strength RSI", "StrengthRSI"),
            ("Strength Stochastic", "StrengthStochastic"),
            ("Strength Z-Score", "StrengthZScore")
        ]
        
        for display_name, oscillator_type in oscillators:
            menu.add_command(
                label=display_name,
                command=lambda ot=oscillator_type: self.open_oscillator_drilldown(currency, ot)
            )
        
        # Show menu at cursor position
        try:
            menu.tk_popup(event.x_root, event.y_root)
        finally:
            menu.grab_release()
    
    def open_oscillator_drilldown(self, currency: str, oscillator_type: str):
        """Open oscillator drill-down window"""
        
        try:
            drilldown_window = OscillatorDrilldownWindow(self, currency, oscillator_type)
            show_info(f"Opened {oscillator_type} analysis for {currency}")
        except Exception as e:
            show_warning(f"Failed to open oscillator analysis: {e}")
    
    def toggle_heatmap(self):
        """Toggle heatmap visibility"""
        
        if self.heatmap_visible:
            # Hide heatmap
            self.heatmap_content.pack_forget()
            self.heatmap_toggle.configure(text="📊 Show Currency Strength Heatmap")
            self.heatmap_visible = False
        else:
            # Show heatmap
            self.heatmap_content.pack(fill="x", padx=10, pady=10)
            self.heatmap_toggle.configure(text="📊 Hide Currency Strength Heatmap")
            self.heatmap_visible = True
            
            # Update heatmap with current data
            self.update_heatmap()
    
    def update_heatmap(self):
        """Update heatmap with current currency strength data"""
        if self.heatmap_visible and self.currency_strength_data:
            self.heatmap_widget.update_data(self.currency_strength_data)
    
    def force_refresh(self):
        """Force refresh of all data"""
        
        # Publish refresh request event
        event_bus.publish(
            "force_data_refresh",
            {"timestamp": datetime.now().isoformat()},
            source="strength_tab"
        )
        
        show_info("Data refresh requested")
    
    def export_data(self):
        """Export current data to CSV"""
        
        try:
            import csv
            from tkinter import filedialog
            
            # Ask for save location
            filename = filedialog.asksaveasfilename(
                defaultextension=".csv",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                title="Export Strength Data"
            )
            
            if not filename:
                return
            
            # Export data
            with open(filename, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)
                
                # Write pair data
                writer.writerow(["=== CURRENCY PAIR % CHANGES ==="])
                writer.writerow(["Pair"] + self.timeframes)
                
                for pair, data in self.pair_data.items():
                    row = [pair]
                    for tf in self.timeframes:
                        row.append(data.get(tf, ""))
                    writer.writerow(row)
                
                writer.writerow([])  # Empty row
                
                # Write currency strength data
                writer.writerow(["=== CURRENCY STRENGTH ==="])
                writer.writerow(["Currency"] + self.timeframes)
                
                for currency, data in self.currency_strength_data.items():
                    row = [currency]
                    for tf in self.timeframes:
                        row.append(data.get(tf, ""))
                    writer.writerow(row)
                
                # Write metadata
                writer.writerow([])
                writer.writerow(["=== METADATA ==="])
                writer.writerow(["Export Time", datetime.now().isoformat()])
                writer.writerow(["Update Interval", f"{self.update_interval}s"])
            
            show_info(f"Data exported to {filename}")
            
        except Exception as e:
            show_warning(f"Export failed: {e}")
    
    def show_settings(self):
        """Show settings dialog"""
        
        # Create settings window
        settings_window = ctk.CTkToplevel(self)
        settings_window.title("Strength Tab Settings")
        settings_window.geometry("400x300")
        settings_window.configure(fg_color=ColorPalette.DARK_SURFACE)
        
        # Make modal
        settings_window.transient(self)
        settings_window.grab_set()
        
        # Settings content
        content_frame = ctk.CTkFrame(settings_window)
        content_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Update interval setting
        interval_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        interval_frame.pack(fill="x", pady=10)
        
        ctk.CTkLabel(
            interval_frame,
            text="Update Interval (seconds):",
            font=ctk.CTkFont(family="Arial", size=12)
        ).pack(anchor="w")
        
        interval_slider = ctk.CTkSlider(
            interval_frame,
            from_=0.1,
            to=10.0,
            number_of_steps=99
        )
        interval_slider.pack(fill="x", pady=5)
        interval_slider.set(self.update_interval)
        
        # Timeframe selection
        timeframe_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        timeframe_frame.pack(fill="x", pady=10)
        
        ctk.CTkLabel(
            timeframe_frame,
            text="Visible Timeframes:",
            font=ctk.CTkFont(family="Arial", size=12)
        ).pack(anchor="w")
        
        # Timeframe checkboxes
        tf_vars = {}
        for tf in self.timeframes:
            var = tk.BooleanVar(value=True)
            tf_vars[tf] = var
            
            checkbox = ctk.CTkCheckBox(
                timeframe_frame,
                text=tf,
                variable=var
            )
            checkbox.pack(anchor="w", pady=2)
        
        # Buttons
        button_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        button_frame.pack(fill="x", pady=20)
        
        def apply_settings():
            # Apply new settings
            self.update_interval = interval_slider.get()
            self.frequency_slider.set(self.update_interval)
            self.frequency_label.configure(text=f"{self.update_interval:.1f}s")
            
            # Update timeframes (implementation would filter columns)
            # This would require rebuilding tables - simplified for now
            
            settings_window.destroy()
            show_info("Settings applied")
        
        def cancel_settings():
            settings_window.destroy()
        
        apply_button = ctk.CTkButton(
            button_frame,
            text="Apply",
            command=apply_settings
        )
        apply_button.pack(side="right", padx=(10, 0))
        
        cancel_button = ctk.CTkButton(
            button_frame,
            text="Cancel",
            command=cancel_settings
        )
        cancel_button.pack(side="right")
    
    def start_update_loop(self):
        """Start the update loop for real-time display"""
        self.update_display()
        
        # Schedule next update
        next_update_ms = int(self.update_interval * 1000)
        self.after(next_update_ms, self.start_update_loop)
    
    def update_display(self):
        """Update display with current data"""
        
        current_time = datetime.now()
        
        # Check if enough time has passed since last update
        time_diff = (current_time - self.last_update).total_seconds()
        if time_diff < self.update_interval:
            return
        
        try:
            with self.update_lock:
                # Update pair table
                if self.pair_data:
                    pair_rows = []
                    for pair, data in self.pair_data.items():
                        row = {"name": pair}
                        for tf in self.timeframes:
                            row[tf] = data.get(tf, 0.0)
                        pair_rows.append(row)
                    
                    self.pair_table.update_rows(pair_rows)
                
                # Update currency strength table
                if self.currency_strength_data:
                    strength_rows = []
                    for currency, data in self.currency_strength_data.items():
                        row = {"name": currency}
                        for tf in self.timeframes:
                            row[tf] = data.get(tf, 0.0)
                        strength_rows.append(row)
                    
                    self.strength_table.update_rows(strength_rows)
                
                # Update heatmap if visible
                if self.heatmap_visible:
                    self.update_heatmap()
            
            self.last_update = current_time
            
        except Exception as e:
            print(f"Error updating strength tab display: {e}")

# Integration function for main application
def integrate_strength_tab(notebook_widget) -> StrengthAndPercentChangeTab:
    """
    Integration function to add strength tab to main notebook
    
    Args:
        notebook_widget: CTkTabview or similar notebook widget
        
    Returns:
        StrengthAndPercentChangeTab instance
    """
    
    strength_tab = StrengthAndPercentChangeTab(notebook_widget)
    
    # Add to notebook (assuming CTkTabview)
    if hasattr(notebook_widget, 'add'):
        notebook_widget.add("💪 Strength & Changes")
        tab_frame = notebook_widget.tab("💪 Strength & Changes")
        strength_tab.pack(fill="both", expand=True)
    
    return strength_tab

🎛️ PHASE 4: COMMAND PALETTE (Day 3-4)
Step 4.1: Command Palette Implementation
File: src/ui/command_palette.py
python"""
Command Palette - Fuzzy search interface for quick actions and navigation
"""

import customtkinter as ctk
import tkinter as tk
from typing import Dict, List, Optional, Callable, Any, Tuple
import threading
import re
from dataclasses import dataclass
from datetime import datetime

from ..core.event_bus import event_bus
from ..core.state_manager import state_manager
from ..themes.colors import ColorPalette
from .toast_manager import show_info, show_warning

@dataclass
class Command:
    """Command definition for palette"""
    id: str
    title: str
    description: str
    category: str
    keywords: List[str]
    callback: Callable
    shortcut: Optional[str] = None
    enabled: bool = True
    risk_gated: bool = False  # Whether this command respects risk gates

class FuzzyMatcher:
    """Fuzzy string matching for command search"""
    
    @staticmethod
    def score_match(query: str, text: str) -> float:
        """
        Calculate fuzzy match score between query and text
        
        Returns:
            float: Score from 0.0 (no match) to 1.0 (perfect match)
        """
        
        if not query:
            return 1.0
        
        query = query.lower()
        text = text.lower()
        
        # Exact match gets highest score
        if query == text:
            return 1.0
        
        # Substring match
        if query in text:
            # Bonus for match at start
            start_bonus = 0.2 if text.startswith(query) else 0.0
            # Score based on proportion of text matched
            base_score = len(query) / len(text)
            return min(0.95, base_score + start_bonus)
        
        # Character sequence matching
        query_idx = 0
        matched_chars = 0
        
        for char in text:
            if query_idx < len(query) and char == query[query_idx]:
                matched_chars += 1
                query_idx += 1
        
        if matched_chars == len(query):
            # All query characters found in sequence
            return 0.5 * (matched_chars / len(text))
        
        # Partial character matching
        query_chars = set(query)
        text_chars = set(text)
        common_chars = len(query_chars.intersection(text_chars))
        
        if common_chars > 0:
            return 0.2 * (common_chars / len(query_chars))
        
        return 0.0
    
    @staticmethod
    def find_matches(query: str, items: List[str], threshold: float = 0.1) -> List[Tuple[str, float]]:
        """
        Find fuzzy matches in list of items
        
        Args:
            query: Search query
            items: List of strings to search
            threshold: Minimum score threshold
            
        Returns:
            List of (item, score) tuples sorted by score descending
        """
        
        matches = []
        
        for item in items:
            score = FuzzyMatcher.score_match(query, item)
            if score >= threshold:
                matches.append((item, score))
        
        # Sort by score descending
        matches.sort(key=lambda x: x[1], reverse=True)
        
        return matches

class CommandRegistry:
    """Registry for all available commands"""
    
    def __init__(self):
        self.commands: Dict[str, Command] = {}
        self.categories: Dict[str, List[str]] = {}
        
        # Initialize default commands
        self._register_default_commands()
    
    def register_command(self, command: Command):
        """Register a new command"""
        self.commands[command.id] = command
        
        # Add to category
        if command.category not in self.categories:
            self.categories[command.category] = []
        
        if command.id not in self.categories[command.category]:
            self.categories[command.category].append(command.id)
    
    def unregister_command(self, command_id: str):
        """Unregister a command"""
        if command_id in self.commands:
            command = self.commands[command_id]
            
            # Remove from category
            if command.category in self.categories:
                if command_id in self.categories[command.category]:
                    self.categories[command.category].remove(command_id)
            
            # Remove command
            del self.commands[command_id]
    
    def get_command(self, command_id: str) -> Optional[Command]:
        """Get command by ID"""
        return self.commands.get(command_id)
    
    def search_commands(self, query: str, limit: int = 10) -> List[Command]:
        """Search commands using fuzzy matching"""
        
        if not query:
            # Return recent or featured commands
            return list(self.commands.values())[:limit]
        
        # Build searchable strings for each command
        searchable_items = {}
        for cmd_id, command in self.commands.items():
            if not command.enabled:
                continue
                
            # Check risk gating
            if command.risk_gated:
                allowed, _ = state_manager.is_action_allowed()
                if not allowed:
                    continue
            
            # Combine title, description, and keywords for searching
            search_text = f"{command.title} {command.description} {' '.join(command.keywords)}"
            searchable_items[cmd_id] = search_text
        
        # Find matches
        items = list(searchable_items.values())
        item_ids = list(searchable_items.keys())
        
        matches = FuzzyMatcher.find_matches(query, items)
        
        # Convert back to commands
        result_commands = []
        for item, score in matches[:limit]:
            item_index = items.index(item)
            cmd_id = item_ids[item_index]
            command = self.commands[cmd_id]
            result_commands.append(command)
        
        return result_commands
    
    def _register_default_commands(self):
        """Register default system commands"""
        
        # Navigation commands
        nav_commands = [
            Command(
                id="nav_risk_monitor",
                title="Switch to Risk Monitor",
                description="Navigate to Risk Monitor tab",
                category="Navigation",
                keywords=["risk", "monitor", "tab", "switch"],
                callback=self._nav_to_risk_monitor
            ),
            Command(
                id="nav_strength",
                title="Switch to Strength & Changes",
                description="Navigate to Currency Strength tab",
                category="Navigation", 
                keywords=["strength", "currency", "change", "percent", "tab"],
                callback=self._nav_to_strength
            ),
            Command(
                id="nav_indicators",
                title="Switch to Indicators",
                description="Navigate to Indicators tab",
                category="Navigation",
                keywords=["indicators", "signals", "tab"],
                callback=self._nav_to_indicators
            ),
            Command(
                id="nav_rules",
                title="Switch to Rule Matrix",
                description="Navigate to Rule Matrix tab",
                category="Navigation",
                keywords=["rules", "matrix", "strategy", "tab"],
                callback=self._nav_to_rules
            )
        ]
        
        # Risk management commands
        risk_commands = [
            Command(
                id="risk_emergency_stop",
                title="Emergency Stop All",
                description="Immediately stop all trading activity",
                category="Risk Management",
                keywords=["emergency", "stop", "halt", "abort", "all"],
                callback=self._emergency_stop_all,
                risk_gated=False  # Emergency stop always available
            ),
            Command(
                id="risk_close_losing",
                title="Close All Losing Positions",
                description="Close positions that are currently at a loss",
                category="Risk Management",
                keywords=["close", "losing", "loss", "positions"],
                callback=self._close_losing_positions,
                risk_gated=True
            ),
            Command(
                id="risk_reduce_exposure",
                title="Reduce Exposure 50%",
                description="Reduce all position sizes by 50%",
                category="Risk Management",
                keywords=["reduce", "exposure", "size", "half"],
                callback=self._reduce_exposure_50,
                risk_gated=True
            ),
            Command(
                id="risk_set_daily_limit",
                title="Set Daily Risk Limit",
                description="Modify daily risk limit percentage",
                category="Risk Management",
                keywords=["set", "daily", "limit", "risk", "percent"],
                callback=self._set_daily_risk_limit,
                risk_gated=False
            )
        ]
        
        # Data and analysis commands
        data_commands = [
            Command(
                id="data_refresh_all",
                title="Refresh All Data",
                description="Force refresh of all market data",
                category="Data",
                keywords=["refresh", "update", "reload", "data"],
                callback=self._refresh_all_data
            ),
            Command(
                id="data_export_strength",
                title="Export Strength Data",
                description="Export currency strength data to CSV",
                category="Data",
                keywords=["export", "strength", "currency", "csv"],
                callback=self._export_strength_data
            ),
            Command(
                id="data_clear_cache",
                title="Clear Data Cache",
                description="Clear all cached market data",
                category="Data",
                keywords=["clear", "cache", "data", "reset"],
                callback=self._clear_data_cache
            )
        ]
        
        # Search and filter commands
        search_commands = [
            Command(
                id="search_symbol",
                title="Search Symbol",
                description="Find and focus on specific currency pair",
                category="Search",
                keywords=["search", "find", "symbol", "pair", "currency"],
                callback=self._search_symbol
            ),
            Command(
                id="filter_high_risk",
                title="Filter High Risk Pairs",
                description="Show only pairs with high risk exposure",
                category="Search",
                keywords=["filter", "high", "risk", "exposure"],
                callback=self._filter_high_risk
            ),
            Command(
                id="filter_volatile",
                title="Filter High Volatility",
                description="Show only highly volatile currency pairs",
                category="Search",
                keywords=["filter", "volatile", "volatility", "movement"],
                callback=self._filter_volatile
            )
        ]
        
        # Settings commands
        settings_commands = [
            Command(
                id="settings_theme",
                title="Toggle Theme",
                description="Switch between dark and light themes",
                category="Settings",
                keywords=["theme", "dark", "light", "toggle"],
                callback=self._toggle_theme
            ),
            Command(
                id="settings_sounds",
                title="Toggle Sound Alerts",
                description="Enable/disable audio notifications",
                category="Settings",
                keywords=["sound", "audio", "alerts", "notification"],
                callback=self._toggle_sounds
            ),
            Command(
                id="settings_workspace",
                title="Reset Workspace Layout",
                description="Reset window layout to default",
                category="Settings",
                keywords=["reset", "workspace", "layout", "default"],
                callback=self._reset_workspace
            )
        ]
        
        # Register all commands
        all_commands = nav_commands + risk_commands + data_commands + search_commands + settings_commands
        
        for command in all_commands:
            self.register_command(command)
    
    # Command callback implementations
    def _nav_to_risk_monitor(self):
        event_bus.publish("navigate_to_tab", {"tab": "risk_monitor"}, "command_palette")
    
    def _nav_to_strength(self):
        event_bus.publish("navigate_to_tab", {"tab": "strength"}, "command_palette")
    
    def _nav_to_indicators(self):
        event_bus.publish("navigate_to_tab", {"tab": "indicators"}, "command_palette")
    
    def _nav_to_rules(self):
        event_bus.publish("navigate_to_tab", {"tab": "rules"}, "command_palette")
    
    def _emergency_stop_all(self):
        event_bus.publish("emergency_stop_triggered", {}, "command_palette")
        show_warning("Emergency stop triggered from command palette")
    
    def _close_losing_positions(self):
        event_bus.publish("close_losing_positions", {}, "command_palette")
        show_info("Closing all losing positions...")
    
    def _reduce_exposure_50(self):
        event_bus.publish("reduce_exposure", {"factor": 0.5}, "command_palette")
        show_info("Reducing all exposure by 50%...")
    
    def _set_daily_risk_limit(self):
        # This would open a dialog to set the limit
        event_bus.publish("show_risk_limit_dialog", {}, "command_palette")
    
    def _refresh_all_data(self):
        event_bus.publish("force_data_refresh", {}, "command_palette")
        show_info("Refreshing all data...")
    
    def _export_strength_data(self):
        event_bus.publish("export_strength_data", {}, "command_palette")
    
    def _clear_data_cache(self):
        event_bus.publish("clear_data_cache", {}, "command_palette")
        show_info("Data cache cleared")
    
    def _search_symbol(self):
        # This would open symbol search dialog
        event_bus.publish("show_symbol_search", {}, "command_palette")
    
    def _filter_high_risk(self):
        event_bus.publish("apply_filter", {"filter_type": "high_risk"}, "command_palette")
    
    def _filter_volatile(self):
        event_bus.publish("apply_filter", {"filter_type": "high_volatility"}, "command_palette")
    
    def _toggle_theme(self):
        event_bus.publish("toggle_theme", {}, "command_palette")
    
    def _toggle_sounds(self):
        event_bus.publish("toggle_sounds", {}, "command_palette")
    
    def _reset_workspace(self):
        event_bus.publish("reset_workspace", {}, "command_palette")
        show_info("Workspace layout reset to default")

class CommandPaletteWidget(ctk.CTkToplevel):
    """Command palette popup window"""
    
    def __init__(self, master, command_registry: CommandRegistry):
        super().__init__(master)
        
        self.command_registry = command_registry
        self.current_commands: List[Command] = []
        self.selected_index = 0
        
        # Window configuration
        self.title("Command Palette")
        self.geometry("600x400")
        self.configure(fg_color=ColorPalette.DARK_SURFACE)
        
        # Make window modal and centered
        self.transient(master)
        self.grab_set()
        self.center_window()
        
        # Remove window decorations for clean look
        self.overrideredirect(True)
        
        self.setup_ui()
        self.setup_bindings()
        
        # Initial search
        self.perform_search("")
    
    def center_window(self):
        """Center the window on screen"""
        self.update_idletasks()
        
        # Get window dimensions
        width = self.winfo_reqwidth()
        height = self.winfo_reqheight()
        
        # Get screen dimensions
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        
        # Calculate position
        x = (screen_width - width) // 2
        y = (screen_height - height) // 3  # Slightly above center
        
        self.geometry(f"{width}x{height}+{x}+{y}")
    
    def setup_ui(self):
        """Setup command palette UI"""
        
        # Main container with border
        main_frame = ctk.CTkFrame(
            self,
            fg_color=ColorPalette.DARK_SURFACE_VARIANT,
            border_width=2,
            border_color=ColorPalette.INFO,
            corner_radius=8
        )
        main_frame.pack(fill="both", expand=True, padx=2, pady=2)
        
        # Search box
        search_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        search_frame.pack(fill="x", padx=10, pady=10)
        
        # Search icon and entry
        search_container = ctk.CTkFrame(search_frame, fg_color=ColorPalette.DARK_SURFACE)
        search_container.pack(fill="x")
        
        search_icon = ctk.CTkLabel(
            search_container,
            text="🔍",
            font=ctk.CTkFont(family="Arial", size=16),
            width=30
        )
        search_icon.pack(side="left", padx=(10, 5), pady=8)
        
        self.search_entry = ctk.CTkEntry(
            search_container,
            placeholder_text="Type command or search...",
            font=ctk.CTkFont(family="Arial", size=14),
            fg_color="transparent",
            border_width=0
        )
        self.search_entry.pack(side="left", fill="x", expand=True, padx=(0, 10), pady=8)
        
        # Results frame
        results_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        results_frame.pack(fill="both", expand=True, padx=10, pady=(0, 10))
        
        # Results scrollable frame
        self.results_scrollable = ctk.CTkScrollableFrame(
            results_frame,
            fg_color=ColorPalette.DARK_SURFACE,
            scrollbar_button_color=ColorPalette.DARK_BORDER,
            scrollbar_button_hover_color=ColorPalette.INFO
        )
        self.results_scrollable.pack(fill="both", expand=True)
        
        # Status bar
        status_frame = ctk.CTkFrame(main_frame, fg_color="transparent", height=25)
        status_frame.pack(fill="x", padx=10, pady=(0, 10))
        status_frame.pack_propagate(False)
        
        self.status_label = ctk.CTkLabel(
            status_frame,
            text="Type to search commands...",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        self.status_label.pack(side="left", pady=2)
        
        shortcut_label = ctk.CTkLabel(
            status_frame,
            text="↑↓ Navigate • Enter Execute • Esc Close",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        shortcut_label.pack(side="right", pady=2)
    
    def setup_bindings(self):
        """Setup keyboard bindings"""
        
        # Search entry bindings
        self.search_entry.bind("<KeyRelease>", self.on_search_changed)
        self.search_entry.bind("<Up>", self.on_up_key)
        self.search_entry.bind("<Down>", self.on_down_key)
        self.search_entry.bind("<Return>", self.on_enter_key)
        self.search_entry.bind("<Escape>", self.on_escape_key)
        
        # Window bindings
        self.bind("<Escape>", self.on_escape_key)
        
        # Focus search entry
        self.search_entry.focus_set()
    
    def on_search_changed(self, event):
        """Handle search text changes"""
        query = self.search_entry.get()
        self.perform_search(query)
    
    def on_up_key(self, event):
        """Handle up arrow key"""
        if self.current_commands:
            self.selected_index = max(0, self.selected_index - 1)
            self.update_selection()
        return "break"  # Prevent default behavior
    
    def on_down_key(self, event):
        """Handle down arrow key"""
        if self.current_commands:
            self.selected_index = min(len(self.current_commands) - 1, self.selected_index + 1)
            self.update_selection()
        return "break"  # Prevent default behavior
    
    def on_enter_key(self, event):
        """Handle enter key - execute selected command"""
        if self.current_commands and 0 <= self.selected_index < len(self.current_commands):
            command = self.current_commands[self.selected_index]
            self.execute_command(command)
        return "break"
    
    def on_escape_key(self, event):
        """Handle escape key - close palette"""
        self.close_palette()
    
    def perform_search(self, query: str):
        """Perform command search and update results"""
        
        # Search commands
        self.current_commands = self.command_registry.search_commands(query, limit=20)
        self.selected_index = 0
        
        # Update results display
        self.update_results()
        
        # Update status
        if query:
            self.status_label.configure(text=f"Found {len(self.current_commands)} commands")
        else:
            self.status_label.configure(text="Showing all available commands")
    
    def update_results(self):
        """Update the results display"""
        
        # Clear existing results
        for widget in self.results_scrollable.winfo_children():
            widget.destroy()
        
        # Add command items
        for i, command in enumerate(self.current_commands):
            self.create_command_item(command, i)
        
        # Update selection
        self.update_selection()
    
    def create_command_item(self, command: Command, index: int):
        """Create a command item widget"""
        
        # Command frame
        cmd_frame = ctk.CTkFrame(
            self.results_scrollable,
            fg_color="transparent",
            corner_radius=4
        )
        cmd_frame.pack(fill="x", padx=5, pady=2)
        
        # Store index for selection
        cmd_frame.command_index = index
        
        # Content frame
        content_frame = ctk.CTkFrame(cmd_frame, fg_color="transparent")
        content_frame.pack(fill="x", padx=8, pady=6)
        
        # Left side: title and description
        left_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        left_frame.pack(side="left", fill="x", expand=True)
        
        # Title
        title_label = ctk.CTkLabel(
            left_frame,
            text=command.title,
            font=ctk.CTkFont(family="Arial", size=13, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            anchor="w"
        )
        title_label.pack(anchor="w")
        
        # Description
        desc_label = ctk.CTkLabel(
            left_frame,
            text=command.description,
            font=ctk.CTkFont(family="Arial", size=11),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            anchor="w"
        )
        desc_label.pack(anchor="w", pady=(2, 0))
        
        # Right side: category and shortcut
        right_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        right_frame.pack(side="right")
        
        # Category badge
        category_badge = ctk.CTkLabel(
            right_frame,
            text=command.category,
            font=ctk.CTkFont(family="Arial", size=9),
            text_color=ColorPalette.INFO,
            fg_color=ColorPalette.DARK_SURFACE,
            corner_radius=12,
            width=80,
            height=20
        )
        category_badge.pack(pady=(0, 2))
        
        # Shortcut (if available)
        if command.shortcut:
            shortcut_label = ctk.CTkLabel(
                right_frame,
                text=command.shortcut,
                font=ctk.CTkFont(family="Arial", size=9),
                text_color=ColorPalette.DARK_TEXT_SECONDARY
            )
            shortcut_label.pack()
        
        # Click binding
        def on_click(event, cmd=command):
            self.execute_command(cmd)
        
        # Bind click to all elements
        for widget in [cmd_frame, content_frame, left_frame, title_label, desc_label]:
            widget.bind("<Button-1>", on_click)
    
    def update_selection(self):
        """Update visual selection highlighting"""
        
        # Get all command frames
        cmd_frames = [widget for widget in self.results_scrollable.winfo_children() 
                     if hasattr(widget, 'command_index')]
        
        # Update highlighting
        for i, frame in enumerate(cmd_frames):
            if i == self.selected_index:
                frame.configure(fg_color=ColorPalette.INFO)
            else:
                frame.configure(fg_color="transparent")
    
    def execute_command(self, command: Command):
        """Execute the selected command"""
        
        try:
            # Check if command is enabled
            if not command.enabled:
                show_warning(f"Command '{command.title}' is currently disabled")
                return
            
            # Check risk gating
            if command.risk_gated:
                allowed, reason = state_manager.is_action_allowed()
                if not allowed:
                    show_warning(f"Command blocked by risk policy: {reason}")
                    return
            
            # Execute command
            if command.callback:
                command.callback()
                
                # Publish command execution event
                event_bus.publish(
                    "command_executed",
                    {
                        "command_id": command.id,
                        "command_title": command.title,
                        "timestamp": datetime.now().isoformat()
                    },
                    "command_palette"
                )
                
                show_info(f"Executed: {command.title}")
            else:
                show_warning(f"Command '{command.title}' has no action defined")
        
        except Exception as e:
            show_warning(f"Failed to execute command: {e}")
        
        finally:
            # Close palette after execution
            self.close_palette()
    
    def close_palette(self):
        """Close the command palette"""
        self.grab_release()
        self.destroy()

class CommandPaletteManager:
    """Manager for command palette functionality"""
    
    def __init__(self, main_window):
        self.main_window = main_window
        self.command_registry = CommandRegistry()
        self.current_palette: Optional[CommandPaletteWidget] = None
        
        # Setup global keyboard shortcut
        self.setup_global_shortcuts()
    
    def setup_global_shortcuts(self):
        """Setup global keyboard shortcuts"""
        
        # Bind Ctrl+K (or Cmd+K on Mac) to open command palette
        self.main_window.bind("<Control-k>", lambda e: self.toggle_palette())
        self.main_window.bind("<Command-k>", lambda e: self.toggle_palette())  # Mac
        
        # Bind F1 for help/commands
        self.main_window.bind("<F1>", lambda e: self.toggle_palette())
        
        # Make sure main window can receive key events
        self.main_window.focus_set()
    
    def toggle_palette(self):
        """Toggle command palette visibility"""
        
        if self.current_palette and self.current_palette.winfo_exists():
            # Close existing palette
            self.current_palette.close_palette()
            self.current_palette = None
        else:
            # Open new palette
            self.show_palette()
    
    def show_palette(self):
        """Show the command palette"""
        
        try:
            # Close any existing palette
            if self.current_palette:
                self.current_palette.destroy()
            
            # Create new palette
            self.current_palette = CommandPaletteWidget(
                self.main_window,
                self.command_registry
            )
            
        except Exception as e:
            show_warning(f"Failed to open command palette: {e}")
    
    def register_command(self, command: Command):
        """Register a new command"""
        self.command_registry.register_command(command)
    
    def unregister_command(self, command_id: str):
        """Unregister a command"""
        self.command_registry.unregister_command(command_id)
    
    def get_registry(self) -> CommandRegistry:
        """Get the command registry"""
        return self.command_registry

# Global command palette manager (to be initialized with main window)
command_palette_manager: Optional[CommandPaletteManager] = None

def initialize_command_palette(main_window) -> CommandPaletteManager:
    """Initialize global command palette manager"""
    global command_palette_manager
    command_palette_manager = CommandPaletteManager(main_window)
    return command_palette_manager

def show_command_palette():
    """Global function to show command palette"""
    if command_palette_manager:
        command_palette_manager.show_palette()

def register_command(command: Command):
    """Global function to register a command"""
    if command_palette_manager:
        command_palette_manager.register_command(command)
CONTINUE TO PHASE 5-10 IN NEXT RESPONSE...
This implementation guide provides exact, detailed instructions for implementing the modern GUI transformation. Each phase builds incrementally while maintaining system stability. The agentic AI should follow these instructions precisely, implementing each file exactly as specified with proper error handling, threading, and integration points.
Key Implementation Notes:

Follow the exact file structure - create directories and files as specified
Implement files in order - each phase depends on previous phases
Test after each phase - verify functionality before proceeding
Use exact imports and class names - maintain integration contracts
Preserve all existing functionality - this is enhancement, not replacement

Would you like me to continue with Phases 5-10 covering the remaining components (Indicator Tab v2, Rule Matrix, Readiness Card, Performance optimizations, and final integration)?RetryDproceedEditMapped out comprehensive implementation strategy for remaining project phases.The user wants me to continue with Phases 5-10 of the implementation guide. I need to provide detailed, exact instructions for the remaining components:

Phase 5: Indicator Tab v2 (Day 4-5)
Phase 6: Rule Matrix upgrades (Day 5-6)
Phase 7: Readiness Card (Day 6)
Phase 8: Performance & Reliability (Day 6-7)
Phase 9: Final Integration (Day 7)
Phase 10: Testing & Deployment (Day 7-8)

I need to maintain the same level of precision and detail as in the previous phases, providing exact file contents, implementation steps, and integration instructions.🤖 HUEY_P GUI Implementation Guide - Phases 5-10

📊 PHASE 5: INDICATOR TAB V2 (Day 4-5)
Step 5.1: Enhanced Indicator Components
File: src/ui/indicator_tab.py
python"""
Indicator Tab v2 - Signal-only, risk-aware presentation
Enhanced with filtering, real-time updates, and status monitoring
"""

import customtkinter as ctk
import tkinter as tk
from tkinter import ttk
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime, timedelta
from dataclasses import dataclass
import threading
import json

from ..core.event_bus import event_bus
from ..core.state_manager import state_manager
from ..themes.colors import ColorPalette, get_risk_color
from .modern_widgets import AdvancedTableWidget, ColoredProgressBar
from .toast_manager import show_info, show_warning, show_danger

@dataclass
class IndicatorSignal:
    """Signal data structure"""
    name: str
    status: str
    symbol: str
    values: Dict[str, Any]
    last_triggered: Optional[datetime]
    confidence: float
    sample_size: int
    enabled: bool = True

@dataclass
class ExpiryServiceSummary:
    """Expiry service status summary"""
    any_active: bool
    overall_strength: float
    active_indicators: int
    total_indicators: int
    last_update: datetime
    health_status: str

class IndicatorSignalCard(ctk.CTkFrame):
    """Individual indicator signal display card"""
    
    def __init__(self, master, signal: IndicatorSignal, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE_VARIANT,
            "border_width": 1,
            "border_color": ColorPalette.DARK_BORDER,
            "corner_radius": 8,
            "height": 120
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.signal = signal
        self.pack_propagate(False)
        
        self.setup_ui()
        self.update_display()
    
    def setup_ui(self):
        """Setup signal card UI"""
        
        # Header with name and status
        header_frame = ctk.CTkFrame(self, fg_color="transparent")
        header_frame.pack(fill="x", padx=8, pady=(8, 4))
        
        # Signal name
        self.name_label = ctk.CTkLabel(
            header_frame,
            text=self.signal.name,
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            anchor="w"
        )
        self.name_label.pack(side="left", fill="x", expand=True)
        
        # Status indicator
        self.status_badge = ctk.CTkLabel(
            header_frame,
            text=self.signal.status,
            font=ctk.CTkFont(family="Arial", size=10, weight="bold"),
            text_color="#FFFFFF",
            fg_color=self._get_status_color(self.signal.status),
            corner_radius=12,
            width=60,
            height=20
        )
        self.status_badge.pack(side="right")
        
        # Content area
        content_frame = ctk.CTkFrame(self, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=8, pady=4)
        
        # Left column: symbol and values
        left_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        left_frame.pack(side="left", fill="both", expand=True)
        
        # Symbol
        symbol_frame = ctk.CTkFrame(left_frame, fg_color="transparent")
        symbol_frame.pack(fill="x")
        
        ctk.CTkLabel(
            symbol_frame,
            text="Symbol:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            width=50,
            anchor="w"
        ).pack(side="left")
        
        self.symbol_label = ctk.CTkLabel(
            symbol_frame,
            text=self.signal.symbol,
            font=ctk.CTkFont(family="Arial", size=10, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            anchor="w"
        )
        self.symbol_label.pack(side="left", fill="x", expand=True)
        
        # Values
        values_frame = ctk.CTkFrame(left_frame, fg_color="transparent")
        values_frame.pack(fill="x", pady=(2, 0))
        
        ctk.CTkLabel(
            values_frame,
            text="Values:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            width=50,
            anchor="w"
        ).pack(side="left")
        
        self.values_label = ctk.CTkLabel(
            values_frame,
            text=self._format_values(self.signal.values),
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            anchor="w",
            wraplength=200
        )
        self.values_label.pack(side="left", fill="x", expand=True)
        
        # Right column: confidence and last triggered
        right_frame = ctk.CTkFrame(content_frame, fg_color="transparent", width=100)
        right_frame.pack(side="right", fill="y")
        right_frame.pack_propagate(False)
        
        # Confidence meter
        conf_frame = ctk.CTkFrame(right_frame, fg_color="transparent")
        conf_frame.pack(fill="x", pady=(0, 4))
        
        ctk.CTkLabel(
            conf_frame,
            text="Confidence",
            font=ctk.CTkFont(family="Arial", size=9),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        ).pack()
        
        self.confidence_bar = ColoredProgressBar(
            conf_frame,
            width=80,
            height=8
        )
        self.confidence_bar.pack(pady=2)
        
        self.confidence_label = ctk.CTkLabel(
            conf_frame,
            text=f"{self.signal.confidence:.0%}",
            font=ctk.CTkFont(family="Arial", size=9),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        self.confidence_label.pack()
        
        # Last triggered
        trigger_frame = ctk.CTkFrame(right_frame, fg_color="transparent")
        trigger_frame.pack(fill="x")
        
        ctk.CTkLabel(
            trigger_frame,
            text="Last Triggered",
            font=ctk.CTkFont(family="Arial", size=9),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        ).pack()
        
        self.last_triggered_label = ctk.CTkLabel(
            trigger_frame,
            text=self._format_last_triggered(self.signal.last_triggered),
            font=ctk.CTkFont(family="Arial", size=9),
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            wraplength=90
        )
        self.last_triggered_label.pack()
    
    def _get_status_color(self, status: str) -> str:
        """Get color for status badge"""
        status_colors = {
            "ACTIVE": ColorPalette.SUCCESS,
            "PENDING": ColorPalette.WARNING,
            "INACTIVE": ColorPalette.DARK_TEXT_SECONDARY,
            "ERROR": ColorPalette.DANGER,
            "DISABLED": "#666666"
        }
        return status_colors.get(status.upper(), ColorPalette.INFO)
    
    def _format_values(self, values: Dict[str, Any]) -> str:
        """Format values dictionary for display"""
        if not values:
            return "No values"
        
        formatted_parts = []
        for key, value in list(values.items())[:3]:  # Show max 3 values
            if isinstance(value, float):
                formatted_parts.append(f"{key}: {value:.2f}")
            else:
                formatted_parts.append(f"{key}: {value}")
        
        if len(values) > 3:
            formatted_parts.append("...")
        
        return ", ".join(formatted_parts)
    
    def _format_last_triggered(self, last_triggered: Optional[datetime]) -> str:
        """Format last triggered time"""
        if not last_triggered:
            return "Never"
        
        now = datetime.now()
        diff = now - last_triggered
        
        if diff.total_seconds() < 60:
            return f"{int(diff.total_seconds())}s ago"
        elif diff.total_seconds() < 3600:
            return f"{int(diff.total_seconds() / 60)}m ago"
        elif diff.total_seconds() < 86400:
            return f"{int(diff.total_seconds() / 3600)}h ago"
        else:
            return f"{int(diff.total_seconds() / 86400)}d ago"
    
    def update_signal(self, signal: IndicatorSignal):
        """Update signal data and refresh display"""
        self.signal = signal
        self.update_display()
    
    def update_display(self):
        """Update display elements"""
        
        # Update status badge
        self.status_badge.configure(
            text=self.signal.status,
            fg_color=self._get_status_color(self.signal.status)
        )
        
        # Update symbol
        self.symbol_label.configure(text=self.signal.symbol)
        
        # Update values
        self.values_label.configure(text=self._format_values(self.signal.values))
        
        # Update confidence
        self.confidence_bar.set_value_with_color(self.signal.confidence, 1.0)
        self.confidence_label.configure(text=f"{self.signal.confidence:.0%}")
        
        # Update last triggered
        self.last_triggered_label.configure(
            text=self._format_last_triggered(self.signal.last_triggered)
        )
        
        # Dim card if disabled or low confidence
        if not self.signal.enabled or self.signal.confidence < 0.3:
            self.configure(border_color="#444444")
            for child in self.winfo_children():
                self._dim_widget(child)
        else:
            self.configure(border_color=ColorPalette.DARK_BORDER)
    
    def _dim_widget(self, widget):
        """Recursively dim a widget and its children"""
        try:
            if hasattr(widget, 'configure'):
                if hasattr(widget, 'cget'):
                    # Dim text color
                    try:
                        current_color = widget.cget('text_color')
                        if current_color and current_color != "#666666":
                            widget.configure(text_color="#666666")
                    except:
                        pass
            
            # Recursively dim children
            for child in widget.winfo_children():
                self._dim_widget(child)
        except:
            pass

class ExpiryServiceCard(ctk.CTkFrame):
    """Expiry service status summary card"""
    
    def __init__(self, master, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE_VARIANT,
            "border_width": 1,
            "border_color": ColorPalette.DARK_BORDER,
            "corner_radius": 8,
            "height": 140
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.summary: Optional[ExpiryServiceSummary] = None
        self.pack_propagate(False)
        
        self.setup_ui()
    
    def setup_ui(self):
        """Setup expiry service card UI"""
        
        # Header
        header_frame = ctk.CTkFrame(self, fg_color="transparent")
        header_frame.pack(fill="x", padx=8, pady=(8, 4))
        
        title_label = ctk.CTkLabel(
            header_frame,
            text="Expiry Service Summary",
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            anchor="w"
        )
        title_label.pack(side="left", fill="x", expand=True)
        
        # Health status indicator
        self.health_indicator = ctk.CTkLabel(
            header_frame,
            text="●",
            font=ctk.CTkFont(family="Arial", size=16),
            text_color=ColorPalette.DANGER,
            width=20
        )
        self.health_indicator.pack(side="right")
        
        # Content grid
        content_frame = ctk.CTkFrame(self, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=8, pady=4)
        
        # Configure grid
        content_frame.grid_columnconfigure((0, 1), weight=1)
        content_frame.grid_rowconfigure((0, 1, 2), weight=1)
        
        # Any Active
        active_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        active_frame.grid(row=0, column=0, sticky="w", pady=2)
        
        ctk.CTkLabel(
            active_frame,
            text="Any Active:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            width=80,
            anchor="w"
        ).pack(side="left")
        
        self.any_active_label = ctk.CTkLabel(
            active_frame,
            text="No",
            font=ctk.CTkFont(family="Arial", size=10, weight="bold"),
            text_color=ColorPalette.DANGER
        )
        self.any_active_label.pack(side="left")
        
        # Overall Strength
        strength_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        strength_frame.grid(row=0, column=1, sticky="w", pady=2)
        
        ctk.CTkLabel(
            strength_frame,
            text="Strength:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            width=60,
            anchor="w"
        ).pack(side="left")
        
        self.strength_label = ctk.CTkLabel(
            strength_frame,
            text="0.0",
            font=ctk.CTkFont(family="Arial", size=10, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        self.strength_label.pack(side="left")
        
        # Active Indicators
        indicators_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        indicators_frame.grid(row=1, column=0, sticky="w", pady=2)
        
        ctk.CTkLabel(
            indicators_frame,
            text="Active:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            width=80,
            anchor="w"
        ).pack(side="left")
        
        self.active_indicators_label = ctk.CTkLabel(
            indicators_frame,
            text="0/0",
            font=ctk.CTkFont(family="Arial", size=10, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        self.active_indicators_label.pack(side="left")
        
        # Last Update
        update_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        update_frame.grid(row=1, column=1, sticky="w", pady=2)
        
        ctk.CTkLabel(
            update_frame,
            text="Updated:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            width=60,
            anchor="w"
        ).pack(side="left")
        
        self.last_update_label = ctk.CTkLabel(
            update_frame,
            text="Never",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        self.last_update_label.pack(side="left")
        
        # Progress bar for overall health
        progress_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        progress_frame.grid(row=2, column=0, columnspan=2, sticky="ew", pady=(4, 0))
        
        ctk.CTkLabel(
            progress_frame,
            text="Health Score:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        ).pack(anchor="w")
        
        self.health_progress = ColoredProgressBar(
            progress_frame,
            height=8
        )
        self.health_progress.pack(fill="x", pady=2)
    
    def update_summary(self, summary: ExpiryServiceSummary):
        """Update summary data and refresh display"""
        self.summary = summary
        self.update_display()
    
    def update_display(self):
        """Update display elements"""
        
        if not self.summary:
            return
        
        # Update any active
        self.any_active_label.configure(
            text="Yes" if self.summary.any_active else "No",
            text_color=ColorPalette.SUCCESS if self.summary.any_active else ColorPalette.DANGER
        )
        
        # Update strength
        self.strength_label.configure(
            text=f"{self.summary.overall_strength:.1f}",
            text_color=get_risk_color(self.summary.overall_strength / 100)
        )
        
        # Update active indicators
        self.active_indicators_label.configure(
            text=f"{self.summary.active_indicators}/{self.summary.total_indicators}"
        )
        
        # Update last update
        if self.summary.last_update:
            time_diff = datetime.now() - self.summary.last_update
            if time_diff.total_seconds() < 60:
                update_text = f"{int(time_diff.total_seconds())}s ago"
            elif time_diff.total_seconds() < 3600:
                update_text = f"{int(time_diff.total_seconds() / 60)}m ago"
            else:
                update_text = f"{int(time_diff.total_seconds() / 3600)}h ago"
        else:
            update_text = "Never"
        
        self.last_update_label.configure(text=update_text)
        
        # Update health indicator
        health_colors = {
            "EXCELLENT": ColorPalette.SUCCESS,
            "GOOD": ColorPalette.SUCCESS,
            "WARNING": ColorPalette.WARNING,
            "ERROR": ColorPalette.DANGER,
            "OFFLINE": "#666666"
        }
        
        self.health_indicator.configure(
            text_color=health_colors.get(self.summary.health_status, ColorPalette.DANGER)
        )
        
        # Update health progress
        health_score = self.summary.active_indicators / max(self.summary.total_indicators, 1)
        self.health_progress.set_value_with_color(health_score, 1.0)

class SignalFiltersPanel(ctk.CTkFrame):
    """Signal filtering and configuration panel"""
    
    def __init__(self, master, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE_VARIANT,
            "border_width": 1,
            "border_color": ColorPalette.DARK_BORDER,
            "corner_radius": 8,
            "height": 80
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.pack_propagate(False)
        
        # Filter callbacks
        self.on_filter_changed: Optional[Callable] = None
        
        self.setup_ui()
    
    def setup_ui(self):
        """Setup filters panel UI"""
        
        # Title
        title_frame = ctk.CTkFrame(self, fg_color="transparent", height=30)
        title_frame.pack(fill="x", padx=8, pady=(8, 0))
        title_frame.pack_propagate(False)
        
        title_label = ctk.CTkLabel(
            title_frame,
            text="Signal Filters",
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        title_label.pack(side="left", pady=4)
        
        # Reset button
        reset_button = ctk.CTkButton(
            title_frame,
            text="Reset",
            font=ctk.CTkFont(family="Arial", size=10),
            width=50,
            height=24,
            command=self.reset_filters
        )
        reset_button.pack(side="right", pady=4)
        
        # Filters container
        filters_frame = ctk.CTkFrame(self, fg_color="transparent")
        filters_frame.pack(fill="x", padx=8, pady=4)
        
        # Min Sample Size
        sample_frame = ctk.CTkFrame(filters_frame, fg_color="transparent")
        sample_frame.pack(side="left", padx=(0, 15))
        
        ctk.CTkLabel(
            sample_frame,
            text="Min Sample:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        ).pack(side="left", padx=(0, 5))
        
        self.min_sample_slider = ctk.CTkSlider(
            sample_frame,
            from_=1,
            to=100,
            number_of_steps=99,
            width=100,
            command=self.on_sample_filter_changed
        )
        self.min_sample_slider.pack(side="left", padx=(0, 5))
        self.min_sample_slider.set(10)  # Default minimum
        
        self.min_sample_label = ctk.CTkLabel(
            sample_frame,
            text="10",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            width=30
        )
        self.min_sample_label.pack(side="left")
        
        # Min Probability
        prob_frame = ctk.CTkFrame(filters_frame, fg_color="transparent")
        prob_frame.pack(side="left", padx=(0, 15))
        
        ctk.CTkLabel(
            prob_frame,
            text="Min Probability:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        ).pack(side="left", padx=(0, 5))
        
        self.min_prob_slider = ctk.CTkSlider(
            prob_frame,
            from_=0.0,
            to=1.0,
            number_of_steps=100,
            width=100,
            command=self.on_prob_filter_changed
        )
        self.min_prob_slider.pack(side="left", padx=(0, 5))
        self.min_prob_slider.set(0.6)  # Default 60%
        
        self.min_prob_label = ctk.CTkLabel(
            prob_frame,
            text="60%",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            width=30
        )
        self.min_prob_label.pack(side="left")
        
        # Status Filter
        status_frame = ctk.CTkFrame(filters_frame, fg_color="transparent")
        status_frame.pack(side="left")
        
        ctk.CTkLabel(
            status_frame,
            text="Status:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        ).pack(side="left", padx=(0, 5))
        
        self.status_combo = ctk.CTkComboBox(
            status_frame,
            values=["All", "Active", "Pending", "Inactive"],
            width=80,
            height=24,
            font=ctk.CTkFont(family="Arial", size=10),
            command=self.on_status_filter_changed
        )
        self.status_combo.pack(side="left")
        self.status_combo.set("All")
    
    def on_sample_filter_changed(self, value):
        """Handle min sample filter changes"""
        min_sample = int(value)
        self.min_sample_label.configure(text=str(min_sample))
        
        if self.on_filter_changed:
            self.on_filter_changed("min_sample", min_sample)
    
    def on_prob_filter_changed(self, value):
        """Handle min probability filter changes"""
        min_prob = float(value)
        self.min_prob_label.configure(text=f"{min_prob:.0%}")
        
        if self.on_filter_changed:
            self.on_filter_changed("min_probability", min_prob)
    
    def on_status_filter_changed(self, value):
        """Handle status filter changes"""
        if self.on_filter_changed:
            self.on_filter_changed("status", value)
    
    def reset_filters(self):
        """Reset all filters to defaults"""
        self.min_sample_slider.set(10)
        self.min_prob_slider.set(0.6)
        self.status_combo.set("All")
        
        # Trigger change events
        self.on_sample_filter_changed(10)
        self.on_prob_filter_changed(0.6)
        self.on_status_filter_changed("All")
    
    def get_filter_values(self) -> Dict[str, Any]:
        """Get current filter values"""
        return {
            "min_sample": int(self.min_sample_slider.get()),
            "min_probability": float(self.min_prob_slider.get()),
            "status": self.status_combo.get()
        }

class IndicatorTabV2(ctk.CTkFrame):
    """Main Indicator Tab v2 - Signal-only, risk-aware presentation"""
    
    def __init__(self, master, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE,
            "corner_radius": 0
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **kwargs)
        
        # Data storage
        self.signals: Dict[str, IndicatorSignal] = {}
        self.expiry_summary: Optional[ExpiryServiceSummary] = None
        self.filtered_signals: List[IndicatorSignal] = []
        
        # Update control
        self.update_lock = threading.Lock()
        self.last_update = datetime.now()
        self.update_interval = 2.0  # seconds
        self.poll_interval = 5.0    # Poll external services every 5 seconds
        
        # Filter state
        self.current_filters = {
            "min_sample": 10,
            "min_probability": 0.6,
            "status": "All"
        }
        
        self.setup_ui()
        self.setup_event_handlers()
        self.start_update_loop()
    
    def setup_ui(self):
        """Setup indicator tab UI"""
        
        # Main container
        main_container = ctk.CTkFrame(self, fg_color="transparent")
        main_container.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Top section: Expiry Service Summary and Filters
        top_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        top_frame.pack(fill="x", pady=(0, 10))
        
        # Configure grid for top section
        top_frame.grid_columnconfigure(0, weight=1)
        top_frame.grid_columnconfigure(1, weight=2)
        top_frame.grid_rowconfigure(0, weight=1)
        
        # Expiry Service Summary (left)
        self.expiry_card = ExpiryServiceCard(top_frame)
        self.expiry_card.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        
        # Filters Panel (right)
        self.filters_panel = SignalFiltersPanel(top_frame)
        self.filters_panel.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
        self.filters_panel.on_filter_changed = self.on_filter_changed
        
        # Middle section: Controls
        controls_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        controls_frame.pack(fill="x", pady=(0, 10))
        
        # Control buttons
        button_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        button_frame.pack(side="left")
        
        refresh_button = ctk.CTkButton(
            button_frame,
            text="🔄 Refresh Signals",
            font=ctk.CTkFont(family="Arial", size=12),
            width=140,
            command=self.refresh_signals
        )
        refresh_button.pack(side="left", padx=(0, 10))
        
        configure_button = ctk.CTkButton(
            button_frame,
            text="⚙️ Configure",
            font=ctk.CTkFont(family="Arial", size=12),
            width=120,
            command=self.show_configuration
        )
        configure_button.pack(side="left", padx=(0, 10))
        
        export_button = ctk.CTkButton(
            button_frame,
            text="📊 Export",
            font=ctk.CTkFont(family="Arial", size=12),
            width=100,
            command=self.export_signals
        )
        export_button.pack(side="left")
        
        # Status info
        status_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        status_frame.pack(side="right")
        
        self.signal_count_label = ctk.CTkLabel(
            status_frame,
            text="0 signals (0 visible)",
            font=ctk.CTkFont(family="Arial", size=11),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        self.signal_count_label.pack(side="right", padx=(0, 15))
        
        self.last_poll_label = ctk.CTkLabel(
            status_frame,
            text="Last poll: Never",
            font=ctk.CTkFont(family="Arial", size=11),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        self.last_poll_label.pack(side="right")
        
        # Bottom section: Signal Cards
        signals_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        signals_frame.pack(fill="both", expand=True)
        
        # Signals scrollable area
        self.signals_scrollable = ctk.CTkScrollableFrame(
            signals_frame,
            fg_color=ColorPalette.DARK_SURFACE,
            scrollbar_button_color=ColorPalette.DARK_BORDER,
            scrollbar_button_hover_color=ColorPalette.INFO
        )
        self.signals_scrollable.pack(fill="both", expand=True)
        
        # Configure grid for signal cards (3 columns)
        self.signals_scrollable.grid_columnconfigure((0, 1, 2), weight=1)
        
        # Initialize with placeholder
        self.create_placeholder_message()
    
    def setup_event_handlers(self):
        """Setup event handlers for signal updates"""
        
        # Subscribe to indicator events
        event_bus.subscribe("indicator_update", self._handle_indicator_update)
        event_bus.subscribe("expiry_service_update", self._handle_expiry_service_update)
        event_bus.subscribe("signal_configuration_changed", self._handle_config_changed)
    
    def _handle_indicator_update(self, event):
        """Handle indicator update events"""
        data = event.data
        
        with self.update_lock:
            # Update signals based on event data
            if 'signal_name' in data:
                signal = IndicatorSignal(
                    name=data['signal_name'],
                    status=data.get('status', 'UNKNOWN'),
                    symbol=data.get('symbol', ''),
                    values=data.get('values', {}),
                    last_triggered=datetime.fromisoformat(data['last_triggered']) if data.get('last_triggered') else None,
                    confidence=data.get('confidence', 0.0),
                    sample_size=data.get('sample_size', 0),
                    enabled=data.get('enabled', True)
                )
                
                self.signals[signal.name] = signal
    
    def _handle_expiry_service_update(self, event):
        """Handle expiry service update events"""
        data = event.data
        
        with self.update_lock:
            self.expiry_summary = ExpiryServiceSummary(
                any_active=data.get('any_active', False),
                overall_strength=data.get('overall_strength', 0.0),
                active_indicators=data.get('active_indicators', 0),
                total_indicators=data.get('total_indicators', 0),
                last_update=datetime.now(),
                health_status=data.get('health_status', 'UNKNOWN')
            )
    
    def _handle_config_changed(self, event):
        """Handle signal configuration changes"""
        # Refresh signals when configuration changes
        self.refresh_signals()
    
    def on_filter_changed(self, filter_type: str, value: Any):
        """Handle filter changes"""
        self.current_filters[filter_type] = value
        self.apply_filters()
        self.update_signal_cards()
    
    def apply_filters(self):
        """Apply current filters to signals"""
        
        with self.update_lock:
            self.filtered_signals = []
            
            for signal in self.signals.values():
                # Check filters
                passes_filters = True
                
                # Min sample size filter
                if signal.sample_size < self.current_filters["min_sample"]:
                    passes_filters = False
                
                # Min probability filter
                if signal.confidence < self.current_filters["min_probability"]:
                    passes_filters = False
                
                # Status filter
                status_filter = self.current_filters["status"]
                if status_filter != "All" and signal.status.upper() != status_filter.upper():
                    passes_filters = False
                
                if passes_filters:
                    self.filtered_signals.append(signal)
            
            # Sort by confidence descending
            self.filtered_signals.sort(key=lambda s: s.confidence, reverse=True)
    
    def create_placeholder_message(self):
        """Create placeholder message when no signals"""
        
        placeholder_frame = ctk.CTkFrame(
            self.signals_scrollable,
            fg_color="transparent"
        )
        placeholder_frame.grid(row=0, column=0, columnspan=3, pady=50)
        
        placeholder_label = ctk.CTkLabel(
            placeholder_frame,
            text="No signals available\n\nUse 'Refresh Signals' to load indicator data",
            font=ctk.CTkFont(family="Arial", size=14),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            justify="center"
        )
        placeholder_label.pack()
    
    def update_signal_cards(self):
        """Update signal card display"""
        
        # Clear existing cards
        for widget in self.signals_scrollable.winfo_children():
            widget.destroy()
        
        if not self.filtered_signals:
            self.create_placeholder_message()
            return
        
        # Create cards in grid layout (3 columns)
        for i, signal in enumerate(self.filtered_signals):
            row = i // 3
            col = i % 3
            
            card = IndicatorSignalCard(self.signals_scrollable, signal)
            card.grid(row=row, column=col, padx=5, pady=5, sticky="ew")
        
        # Update status labels
        total_signals = len(self.signals)
        visible_signals = len(self.filtered_signals)
        
        self.signal_count_label.configure(
            text=f"{total_signals} signals ({visible_signals} visible)"
        )
    
    def refresh_signals(self):
        """Refresh signals from external sources"""
        
        # Publish refresh request
        event_bus.publish(
            "refresh_indicator_signals",
            {"timestamp": datetime.now().isoformat()},
            source="indicator_tab_v2"
        )
        
        # Update last poll time
        self.last_poll_label.configure(
            text=f"Last poll: {datetime.now().strftime('%H:%M:%S')}"
        )
        
        show_info("Signal refresh requested")
    
    def show_configuration(self):
        """Show signal configuration dialog"""
        
        # Create configuration window
        config_window = ctk.CTkToplevel(self)
        config_window.title("Signal Configuration")
        config_window.geometry("500x400")
        config_window.configure(fg_color=ColorPalette.DARK_SURFACE)
        
        # Make modal
        config_window.transient(self)
        config_window.grab_set()
        
        # Configuration content
        content_frame = ctk.CTkFrame(config_window)
        content_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Title
        title_label = ctk.CTkLabel(
            content_frame,
            text="Signal Configuration",
            font=ctk.CTkFont(family="Arial", size=16, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        title_label.pack(pady=(0, 20))
        
        # Poll interval setting
        interval_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        interval_frame.pack(fill="x", pady=10)
        
        ctk.CTkLabel(
            interval_frame,
            text="Poll Interval (seconds):",
            font=ctk.CTkFont(family="Arial", size=12)
        ).pack(anchor="w")
        
        interval_slider = ctk.CTkSlider(
            interval_frame,
            from_=1.0,
            to=30.0,
            number_of_steps=29
        )
        interval_slider.pack(fill="x", pady=5)
        interval_slider.set(self.poll_interval)
        
        # Stale data threshold
        stale_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        stale_frame.pack(fill="x", pady=10)
        
        ctk.CTkLabel(
            stale_frame,
            text="Stale Data Threshold (seconds):",
            font=ctk.CTkFont(family="Arial", size=12)
        ).pack(anchor="w")
        
        stale_slider = ctk.CTkSlider(
            stale_frame,
            from_=30.0,
            to=300.0,
            number_of_steps=27
        )
        stale_slider.pack(fill="x", pady=5)
        stale_slider.set(120.0)  # Default 2 minutes
        
        # Auto-refresh toggle
        auto_refresh_var = tk.BooleanVar(value=True)
        auto_refresh_check = ctk.CTkCheckBox(
            content_frame,
            text="Auto-refresh signals",
            variable=auto_refresh_var
        )
        auto_refresh_check.pack(anchor="w", pady=10)
        
        # Buttons
        button_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        button_frame.pack(fill="x", pady=20)
        
        def apply_config():
            self.poll_interval = interval_slider.get()
            # Apply other settings...
            config_window.destroy()
            show_info("Configuration applied")
        
        def cancel_config():
            config_window.destroy()
        
        apply_button = ctk.CTkButton(
            button_frame,
            text="Apply",
            command=apply_config
        )
        apply_button.pack(side="right", padx=(10, 0))
        
        cancel_button = ctk.CTkButton(
            button_frame,
            text="Cancel",
            command=cancel_config
        )
        cancel_button.pack(side="right")
    
    def export_signals(self):
        """Export signal data to file"""
        
        try:
            import csv
            from tkinter import filedialog
            
            filename = filedialog.asksaveasfilename(
                defaultextension=".csv",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                title="Export Signal Data"
            )
            
            if not filename:
                return
            
            # Export filtered signals
            with open(filename, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)
                
                # Header
                writer.writerow([
                    "Name", "Status", "Symbol", "Confidence", "Sample Size",
                    "Last Triggered", "Values", "Enabled"
                ])
                
                # Data rows
                for signal in self.filtered_signals:
                    writer.writerow([
                        signal.name,
                        signal.status,
                        signal.symbol,
                        f"{signal.confidence:.2%}",
                        signal.sample_size,
                        signal.last_triggered.isoformat() if signal.last_triggered else "",
                        json.dumps(signal.values),
                        signal.enabled
                    ])
                
                # Metadata
                writer.writerow([])
                writer.writerow(["=== METADATA ==="])
                writer.writerow(["Export Time", datetime.now().isoformat()])
                writer.writerow(["Total Signals", len(self.signals)])
                writer.writerow(["Visible Signals", len(self.filtered_signals)])
                writer.writerow(["Filters Applied", json.dumps(self.current_filters)])
            
            show_info(f"Signals exported to {filename}")
            
        except Exception as e:
            show_warning(f"Export failed: {e}")
    
    def start_update_loop(self):
        """Start the update loop for real-time display"""
        self.update_display()
        
        # Schedule next update
        next_update_ms = int(self.update_interval * 1000)
        self.after(next_update_ms, self.start_update_loop)
    
    def update_display(self):
        """Update display with current data"""
        
        current_time = datetime.now()
        
        # Check if enough time has passed
        time_diff = (current_time - self.last_update).total_seconds()
        if time_diff < self.update_interval:
            return
        
        try:
            with self.update_lock:
                # Update expiry summary card
                if self.expiry_summary:
                    self.expiry_card.update_summary(self.expiry_summary)
                
                # Apply filters and update signal cards
                self.apply_filters()
                self.update_signal_cards()
            
            self.last_update = current_time
            
        except Exception as e:
            print(f"Error updating indicator tab display: {e}")

# Integration function for main application
def integrate_indicator_tab_v2(notebook_widget) -> IndicatorTabV2:
    """
    Integration function to add indicator tab to main notebook
    
    Args:
        notebook_widget: CTkTabview or similar notebook widget
        
    Returns:
        IndicatorTabV2 instance
    """
    
    indicator_tab = IndicatorTabV2(notebook_widget)
    
    # Add to notebook (assuming CTkTabview)
    if hasattr(notebook_widget, 'add'):
        notebook_widget.add("📊 Indicators")
        tab_frame = notebook_widget.tab("📊 Indicators")
        indicator_tab.pack(fill="both", expand=True)
    
    return indicator_tab

🧩 PHASE 6: RULE MATRIX UPGRADES (Day 5-6)
Step 6.1: Enhanced Rule Matrix Implementation
File: src/ui/rule_matrix.py
python"""
Rule Matrix with Progressive Disclosure, Confidence Visualization, and What-If Simulator
"""

import customtkinter as ctk
import tkinter as tk
from tkinter import ttk
from typing import Dict, List, Optional, Any, Callable, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
import threading
import json
import math

from ..core.event_bus import event_bus
from ..core.state_manager import state_manager
from ..themes.colors import ColorPalette, get_risk_color, interpolate_color
from .modern_widgets import AdvancedTableWidget
from .toast_manager import show_info, show_warning, show_success

@dataclass
class RuleCondition:
    """Rule condition definition"""
    parameter: str
    operator: str
    value: Any
    enabled: bool = True

@dataclass
class RuleAction:
    """Rule action definition"""
    action_type: str
    parameters: Dict[str, Any]
    enabled: bool = True

@dataclass
class MatrixRule:
    """Complete rule definition"""
    rule_id: str
    name: str
    conditions: List[RuleCondition]
    action: RuleAction
    confidence: float
    sample_size: int
    expected_return: float
    win_rate: float
    avg_duration: float
    last_triggered: Optional[datetime]
    enabled: bool = True
    tags: List[str] = None

@dataclass
class WhatIfResult:
    """What-if simulation result"""
    rule: MatrixRule
    risk_amount: float
    expected_loss: float
    daily_cap_impact: float
    position_size: float
    probability_success: float
    warnings: List[str]
    can_execute: bool

class ConfidenceHeatmapWidget(ctk.CTkCanvas):
    """Heatmap visualization for rule confidence and sample sizes"""
    
    def __init__(self, master, width: int = 400, height: int = 300, **kwargs):
        
        default_kwargs = {
            "width": width,
            "height": height,
            "bg": ColorPalette.DARK_SURFACE,
            "highlightthickness": 0
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.width = width
        self.height = height
        self.rules: List[MatrixRule] = []
        self.cell_size = 25
        self.margin = 40
        
        # Interaction state
        self.selected_cell: Optional[Tuple[int, int]] = None
        self.hover_cell: Optional[Tuple[int, int]] = None
        
        # Bind events
        self.bind("<Motion>", self.on_mouse_move)
        self.bind("<Button-1>", self.on_click)
        self.bind("<Leave>", self.on_mouse_leave)
    
    def update_rules(self, rules: List[MatrixRule]):
        """Update rules and redraw heatmap"""
        self.rules = rules
        self.redraw()
    
    def redraw(self):
        """Redraw the heatmap"""
        self.delete("all")
        
        if not self.rules:
            self.draw_empty_state()
            return
        
        # Calculate grid dimensions
        max_conditions = max(len(rule.conditions) for rule in self.rules) if self.rules else 1
        grid_width = min(max_conditions, 10)  # Max 10 columns
        grid_height = math.ceil(len(self.rules) / grid_width)
        
        # Draw grid
        for i, rule in enumerate(self.rules):
            row = i // grid_width
            col = i % grid_width
            
            x = self.margin + col * self.cell_size
            y = self.margin + row * self.cell_size
            
            self.draw_rule_cell(rule, x, y, i)
        
        # Draw legend
        self.draw_legend()
    
    def draw_rule_cell(self, rule: MatrixRule, x: int, y: int, index: int):
        """Draw individual rule cell"""
        
        # Determine cell color based on confidence and sample size
        confidence_ratio = rule.confidence
        sample_ratio = min(rule.sample_size / 100, 1.0)  # Normalize to 100 samples
        
        # Base color from confidence
        if confidence_ratio > 0.8:
            base_color = ColorPalette.SUCCESS
        elif confidence_ratio > 0.6:
            base_color = ColorPalette.WARNING
        else:
            base_color = ColorPalette.DANGER
        
        # Opacity based on sample size
        opacity = 0.3 + (sample_ratio * 0.7)  # 30% to 100% opacity
        
        # Create cell
        cell_id = f"cell_{index}"
        
        # Background rectangle
        self.create_rectangle(
            x, y, x + self.cell_size, y + self.cell_size,
            fill=base_color,
            outline=ColorPalette.DARK_BORDER,
            width=1,
            tags=(cell_id, "cell")
        )
        
        # Opacity overlay (simulate transparency)
        if opacity < 1.0:
            overlay_color = interpolate_color(base_color, ColorPalette.DARK_SURFACE, 1 - opacity)
            self.create_rectangle(
                x, y, x + self.cell_size, y + self.cell_size,
                fill=overlay_color,
                outline="",
                tags=(cell_id, "overlay")
            )
        
        # Confidence text
        conf_text = f"{confidence_ratio:.0%}"
        self.create_text(
            x + self.cell_size // 2,
            y + self.cell_size // 2 - 3,
            text=conf_text,
            fill="#FFFFFF" if confidence_ratio > 0.5 else "#000000",
            font=("Arial", 8, "bold"),
            tags=(cell_id, "text")
        )
        
        # Sample size text
        sample_text = f"n={rule.sample_size}"
        self.create_text(
            x + self.cell_size // 2,
            y + self.cell_size // 2 + 6,
            text=sample_text,
            fill="#FFFFFF" if confidence_ratio > 0.5 else "#000000",
            font=("Arial", 6),
            tags=(cell_id, "text")
        )
        
        # Store rule reference
        self.tag_bind(cell_id, "<Button-1>", lambda e, r=rule: self.on_cell_clicked(r))
    
    def draw_legend(self):
        """Draw legend explaining the heatmap"""
        
        legend_x = self.width - 150
        legend_y = 20
        
        # Legend background
        self.create_rectangle(
            legend_x - 10, legend_y - 10,
            legend_x + 140, legend_y + 80,
            fill=ColorPalette.DARK_SURFACE_VARIANT,
            outline=ColorPalette.DARK_BORDER
        )
        
        # Legend title
        self.create_text(
            legend_x + 65, legend_y,
            text="Legend",
            fill=ColorPalette.DARK_TEXT_PRIMARY,
            font=("Arial", 10, "bold")
        )
        
        # Color indicators
        colors = [
            (ColorPalette.SUCCESS, "High Confidence"),
            (ColorPalette.WARNING, "Medium Confidence"),
            (ColorPalette.DANGER, "Low Confidence")
        ]
        
        for i, (color, label) in enumerate(colors):
            y_pos = legend_y + 15 + (i * 15)
            
            # Color square
            self.create_rectangle(
                legend_x, y_pos, legend_x + 10, y_pos + 10,
                fill=color, outline=""
            )
            
            # Label
            self.create_text(
                legend_x + 15, y_pos + 5,
                text=label,
                fill=ColorPalette.DARK_TEXT_PRIMARY,
                font=("Arial", 8),
                anchor="w"
            )
        
        # Opacity explanation
        self.create_text(
            legend_x + 65, legend_y + 65,
            text="Opacity = Sample Size",
            fill=ColorPalette.DARK_TEXT_SECONDARY,
            font=("Arial", 8)
        )
    
    def draw_empty_state(self):
        """Draw empty state message"""
        
        self.create_text(
            self.width // 2, self.height // 2,
            text="No rules available\n\nCreate rules to see confidence heatmap",
            fill=ColorPalette.DARK_TEXT_SECONDARY,
            font=("Arial", 12),
            justify="center"
        )
    
    def on_mouse_move(self, event):
        """Handle mouse movement for hover effects"""
        
        # Find cell under mouse
        cell = self.find_cell_at_position(event.x, event.y)
        
        if cell != self.hover_cell:
            # Clear previous hover
            if self.hover_cell is not None:
                self.clear_hover_effect()
            
            # Apply new hover
            self.hover_cell = cell
            if cell is not None:
                self.apply_hover_effect(cell)
    
    def on_click(self, event):
        """Handle click events"""
        
        cell = self.find_cell_at_position(event.x, event.y)
        if cell is not None and cell < len(self.rules):
            rule = self.rules[cell]
            self.on_cell_clicked(rule)
    
    def on_mouse_leave(self, event):
        """Handle mouse leaving the canvas"""
        if self.hover_cell is not None:
            self.clear_hover_effect()
            self.hover_cell = None
    
    def find_cell_at_position(self, x: int, y: int) -> Optional[int]:
        """Find which cell is at the given position"""
        
        if not self.rules:
            return None
        
        # Calculate grid position
        grid_x = (x - self.margin) // self.cell_size
        grid_y = (y - self.margin) // self.cell_size
        
        if grid_x < 0 or grid_y < 0:
            return None
        
        # Calculate cell index
        max_conditions = max(len(rule.conditions) for rule in self.rules)
        grid_width = min(max_conditions, 10)
        
        cell_index = grid_y * grid_width + grid_x
        
        if cell_index >= len(self.rules):
            return None
        
        return cell_index
    
    def apply_hover_effect(self, cell_index: int):
        """Apply hover effect to cell"""
        if cell_index < len(self.rules):
            # Highlight cell border
            cell_id = f"cell_{cell_index}"
            items = self.find_withtag(cell_id)
            for item in items:
                if "cell" in self.gettags(item):
                    self.itemconfig(item, outline=ColorPalette.INFO, width=2)
    
    def clear_hover_effect(self):
        """Clear hover effects"""
        # Reset all cell borders
        items = self.find_withtag("cell")
        for item in items:
            self.itemconfig(item, outline=ColorPalette.DARK_BORDER, width=1)
    
    def on_cell_clicked(self, rule: MatrixRule):
        """Handle cell click - override in parent"""
        pass

class WhatIfSimulatorDrawer(ctk.CTkFrame):
    """What-if simulator drawer/panel"""
    
    def __init__(self, master, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE_VARIANT,
            "border_width": 1,
            "border_color": ColorPalette.DARK_BORDER,
            "corner_radius": 8
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.current_rule: Optional[MatrixRule] = None
        self.simulation_result: Optional[WhatIfResult] = None
        
        # Callbacks
        self.on_apply_rule: Optional[Callable[[MatrixRule], None]] = None
        
        self.setup_ui()
    
    def setup_ui(self):
        """Setup what-if simulator UI"""
        
        # Header
        header_frame = ctk.CTkFrame(self, fg_color="transparent")
        header_frame.pack(fill="x", padx=10, pady=(10, 5))
        
        title_label = ctk.CTkLabel(
            header_frame,
            text="What-If Simulator",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        title_label.pack(side="left")
        
        close_button = ctk.CTkButton(
            header_frame,
            text="✕",
            width=25,
            height=25,
            command=self.hide
        )
        close_button.pack(side="right")
        
        # Content area
        content_frame = ctk.CTkScrollableFrame(self)
        content_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        # Rule info section
        rule_info_frame = ctk.CTkFrame(content_frame)
        rule_info_frame.pack(fill="x", pady=(0, 10))
        
        rule_info_title = ctk.CTkLabel(
            rule_info_frame,
            text="Selected Rule",
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        rule_info_title.pack(anchor="w", padx=10, pady=(10, 5))
        
        self.rule_name_label = ctk.CTkLabel(
            rule_info_frame,
            text="No rule selected",
            font=ctk.CTkFont(family="Arial", size=11),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            anchor="w"
        )
        self.rule_name_label.pack(fill="x", padx=10, pady=(0, 5))
        
        self.rule_details_label = ctk.CTkLabel(
            rule_info_frame,
            text="",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            anchor="w",
            justify="left"
        )
        self.rule_details_label.pack(fill="x", padx=10, pady=(0, 10))
        
        # Simulation parameters
        params_frame = ctk.CTkFrame(content_frame)
        params_frame.pack(fill="x", pady=(0, 10))
        
        params_title = ctk.CTkLabel(
            params_frame,
            text="Simulation Parameters",
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        params_title.pack(anchor="w", padx=10, pady=(10, 5))
        
        # Account balance
        balance_frame = ctk.CTkFrame(params_frame, fg_color="transparent")
        balance_frame.pack(fill="x", padx=10, pady=5)
        
        ctk.CTkLabel(
            balance_frame,
            text="Account Balance:",
            font=ctk.CTkFont(family="Arial", size=10),
            width=120,
            anchor="w"
        ).pack(side="left")
        
        self.balance_entry = ctk.CTkEntry(
            balance_frame,
            placeholder_text="10000",
            width=100
        )
        self.balance_entry.pack(side="left", padx=(10, 0))
        
        # Risk percentage
        risk_frame = ctk.CTkFrame(params_frame, fg_color="transparent")
        risk_frame.pack(fill="x", padx=10, pady=5)
        
        ctk.CTkLabel(
            risk_frame,
            text="Risk Percentage:",
            font=ctk.CTkFont(family="Arial", size=10),
            width=120,
            anchor="w"
        ).pack(side="left")
        
        self.risk_slider = ctk.CTkSlider(
            risk_frame,
            from_=0.1,
            to=5.0,
            number_of_steps=49,
            width=100,
            command=self.on_risk_changed
        )
        self.risk_slider.pack(side="left", padx=(10, 5))
        self.risk_slider.set(1.0)
        
        self.risk_label = ctk.CTkLabel(
            risk_frame,
            text="1.0%",
            font=ctk.CTkFont(family="Arial", size=10),
            width=40
        )
        self.risk_label.pack(side="left")
        
        # Stop loss
        stop_frame = ctk.CTkFrame(params_frame, fg_color="transparent")
        stop_frame.pack(fill="x", padx=10, pady=(5, 10))
        
        ctk.CTkLabel(
            stop_frame,
            text="Stop Loss (pips):",
            font=ctk.CTkFont(family="Arial", size=10),
            width=120,
            anchor="w"
        ).pack(side="left")
        
        self.stop_loss_entry = ctk.CTkEntry(
            stop_frame,
            placeholder_text="25",
            width=100
        )
        self.stop_loss_entry.pack(side="left", padx=(10, 0))
        
        # Simulate button
        simulate_button = ctk.CTkButton(
            params_frame,
            text="🎯 Run Simulation",
            font=ctk.CTkFont(family="Arial", size=11),
            command=self.run_simulation
        )
        simulate_button.pack(pady=(10, 15))
        
        # Results section
        results_frame = ctk.CTkFrame(content_frame)
        results_frame.pack(fill="x", pady=(0, 10))
        
        results_title = ctk.CTkLabel(
            results_frame,
            text="Simulation Results",
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        results_title.pack(anchor="w", padx=10, pady=(10, 5))
        
        # Results grid
        self.results_grid = ctk.CTkFrame(results_frame, fg_color="transparent")
        self.results_grid.pack(fill="x", padx=10, pady=(0, 10))
        
        # Initially empty - will be populated by simulation
        self.create_empty_results()
        
        # Action buttons
        action_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        action_frame.pack(fill="x", pady=(0, 10))
        
        self.apply_button = ctk.CTkButton(
            action_frame,
            text="📋 Apply to Order Ticket",
            font=ctk.CTkFont(family="Arial", size=11),
            fg_color=ColorPalette.SUCCESS,
            hover_color="#0D8B3A",
            command=self.apply_rule,
            state="disabled"
        )
        self.apply_button.pack(side="right", padx=(10, 0))
        
        save_button = ctk.CTkButton(
            action_frame,
            text="💾 Save Simulation",
            font=ctk.CTkFont(family="Arial", size=11),
            command=self.save_simulation
        )
        save_button.pack(side="right")
    
    def on_risk_changed(self, value):
        """Handle risk slider changes"""
        self.risk_label.configure(text=f"{value:.1f}%")
        
        # Auto-update simulation if rule is loaded
        if self.current_rule:
            self.run_simulation()
    
    def show_rule(self, rule: MatrixRule):
        """Show rule in simulator"""
        
        self.current_rule = rule
        
        # Update rule info
        self.rule_name_label.configure(text=rule.name)
        
        details = f"Confidence: {rule.confidence:.1%}\n"
        details += f"Sample Size: {rule.sample_size}\n"
        details += f"Win Rate: {rule.win_rate:.1%}\n"
        details += f"Expected Return: {rule.expected_return:.2f} pips"
        
        self.rule_details_label.configure(text=details)
        
        # Run initial simulation
        self.run_simulation()
    
    def run_simulation(self):
        """Run what-if simulation"""
        
        if not self.current_rule:
            return
        
        try:
            # Get parameters
            balance_text = self.balance_entry.get() or "10000"
            balance = float(balance_text)
            
            risk_percent = self.risk_slider.get()
            
            stop_loss_text = self.stop_loss_entry.get() or "25"
            stop_loss_pips = float(stop_loss_text)
            
            # Calculate simulation results
            result = self.calculate_simulation(
                self.current_rule,
                balance,
                risk_percent,
                stop_loss_pips
            )
            
            self.simulation_result = result
            self.update_results_display(result)
            
            # Enable apply button if simulation passes checks
            self.apply_button.configure(
                state="normal" if result.can_execute else "disabled"
            )
            
        except ValueError as e:
            show_warning(f"Invalid input: {e}")
        except Exception as e:
            show_warning(f"Simulation failed: {e}")
    
    def calculate_simulation(self, rule: MatrixRule, balance: float, 
                           risk_percent: float, stop_loss_pips: float) -> WhatIfResult:
        """Calculate simulation results"""
        
        # Get current risk constraints
        risk_metrics = state_manager.get_risk_metrics()
        
        # Calculate position size
        risk_amount = balance * (risk_percent / 100)
        pip_value = 1.0  # Simplified - should be calculated based on pair
        position_size = risk_amount / (stop_loss_pips * pip_value)
        
        # Calculate expected outcomes
        expected_loss = risk_amount * (1 - rule.win_rate)
        probability_success = rule.confidence * rule.win_rate
        
        # Calculate daily cap impact
        current_daily_risk = abs(risk_metrics.daily_drawdown)
        daily_cap_impact = (current_daily_risk + risk_percent) / risk_metrics.daily_limit
        
        # Check constraints and generate warnings
        warnings = []
        can_execute = True
        
        # Risk limit check
        if daily_cap_impact > 1.0:
            warnings.append(f"Would exceed daily risk limit ({risk_metrics.daily_limit}%)")
            can_execute = False
        
        # Position size check
        if position_size > 1.0:  # Simplified position limit
            warnings.append("Position size too large")
            can_execute = False
        
        # Confidence check
        if rule.confidence < 0.6:
            warnings.append("Low confidence rule")
        
        # Sample size check
        if rule.sample_size < 30:
            warnings.append("Insufficient sample size")
        
        return WhatIfResult(
            rule=rule,
            risk_amount=risk_amount,
            expected_loss=expected_loss,
            daily_cap_impact=daily_cap_impact,
            position_size=position_size,
            probability_success=probability_success,
            warnings=warnings,
            can_execute=can_execute
        )
    
    def create_empty_results(self):
        """Create empty results display"""
        
        empty_label = ctk.CTkLabel(
            self.results_grid,
            text="Run simulation to see results",
            font=ctk.CTkFont(family="Arial", size=11),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        empty_label.pack(pady=20)
    
    def update_results_display(self, result: WhatIfResult):
        """Update results display with simulation data"""
        
        # Clear existing results
        for widget in self.results_grid.winfo_children():
            widget.destroy()
        
        # Create results grid
        results_data = [
            ("Risk Amount", f"${result.risk_amount:.2f}"),
            ("Position Size", f"{result.position_size:.2f} lots"),
            ("Expected Loss", f"${result.expected_loss:.2f}"),
            ("Success Probability", f"{result.probability_success:.1%}"),
            ("Daily Cap Impact", f"{result.daily_cap_impact:.1%}")
        ]
        
        for i, (label, value) in enumerate(results_data):
            # Label
            label_widget = ctk.CTkLabel(
                self.results_grid,
                text=f"{label}:",
                font=ctk.CTkFont(family="Arial", size=10),
                text_color=ColorPalette.DARK_TEXT_SECONDARY,
                anchor="w"
            )
            label_widget.grid(row=i, column=0, sticky="w", padx=(0, 10), pady=2)
            
            # Value
            # Color code critical values
            if "Risk" in label and result.risk_amount > 1000:
                text_color = ColorPalette.WARNING
            elif "Daily Cap" in label and result.daily_cap_impact > 0.8:
                text_color = ColorPalette.DANGER
            else:
                text_color = ColorPalette.DARK_TEXT_PRIMARY
            
            value_widget = ctk.CTkLabel(
                self.results_grid,
                text=value,
                font=ctk.CTkFont(family="Arial", size=10, weight="bold"),
                text_color=text_color,
                anchor="e"
            )
            value_widget.grid(row=i, column=1, sticky="e", pady=2)
        
        # Configure grid
        self.results_grid.grid_columnconfigure(0, weight=1)
        self.results_grid.grid_columnconfigure(1, weight=1)
        
        # Warnings section
        if result.warnings:
            warnings_frame = ctk.CTkFrame(self.results_grid, fg_color=ColorPalette.DARK_SURFACE)
            warnings_frame.grid(row=len(results_data), column=0, columnspan=2, 
                              sticky="ew", pady=(10, 0))
            
            warning_title = ctk.CTkLabel(
                warnings_frame,
                text="⚠️ Warnings:",
                font=ctk.CTkFont(family="Arial", size=10, weight="bold"),
                text_color=ColorPalette.WARNING
            )
            warning_title.pack(anchor="w", padx=5, pady=(5, 0))
            
            for warning in result.warnings:
                warning_label = ctk.CTkLabel(
                    warnings_frame,
                    text=f"• {warning}",
                    font=ctk.CTkFont(family="Arial", size=9),
                    text_color=ColorPalette.WARNING,
                    anchor="w"
                )
                warning_label.pack(fill="x", padx=10, pady=1)
    
    def apply_rule(self):
        """Apply rule to order ticket"""
        
        if not self.simulation_result or not self.simulation_result.can_execute:
            show_warning("Cannot apply rule - simulation failed checks")
            return
        
        try:
            # Prepare rule application data
            application_data = {
                "rule_id": self.current_rule.rule_id,
                "rule_name": self.current_rule.name,
                "position_size": self.simulation_result.position_size,
                "risk_amount": self.simulation_result.risk_amount,
                "stop_loss_pips": float(self.stop_loss_entry.get() or "25"),
                "expected_return": self.current_rule.expected_return,
                "confidence": self.current_rule.confidence,
                "simulation_timestamp": datetime.now().isoformat()
            }
            
            # Publish application event
            event_bus.publish(
                "apply_rule_to_ticket",
                application_data,
                source="what_if_simulator"
            )
            
            # Call callback if provided
            if self.on_apply_rule:
                self.on_apply_rule(self.current_rule)
            
            show_success(f"Rule '{self.current_rule.name}' applied to order ticket")
            
        except Exception as e:
            show_warning(f"Failed to apply rule: {e}")
    
    def save_simulation(self):
        """Save simulation results"""
        
        if not self.simulation_result:
            show_warning("No simulation to save")
            return
        
        try:
            # Prepare simulation data
            simulation_data = {
                "rule": asdict(self.current_rule),
                "parameters": {
                    "balance": float(self.balance_entry.get() or "10000"),
                    "risk_percent": self.risk_slider.get(),
                    "stop_loss_pips": float(self.stop_loss_entry.get() or "25")
                },
                "results": asdict(self.simulation_result),
                "timestamp": datetime.now().isoformat()
            }
            
            # Save to file (simplified - could use database)
            filename = f"simulation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            
            import os
            os.makedirs("simulations", exist_ok=True)
            
            with open(f"simulations/{filename}", 'w') as f:
                json.dump(simulation_data, f, indent=2, default=str)
            
            show_info(f"Simulation saved as {filename}")
            
        except Exception as e:
            show_warning(f"Failed to save simulation: {e}")
    
    def hide(self):
        """Hide the simulator drawer"""
        self.pack_forget()

class RuleMatrixTab(ctk.CTkFrame):
    """Enhanced Rule Matrix with progressive disclosure and what-if simulator"""
    
    def __init__(self, master, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE,
            "corner_radius": 0
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        # Data storage
        self.rules: List[MatrixRule] = []
        self.filtered_rules: List[MatrixRule] = []
        self.update_lock = threading.Lock()
        
        # UI state
        self.simple_mode = True  # Start in simple mode
        self.simulator_visible = False
        
        self.setup_ui()
        self.setup_event_handlers()
        self.load_sample_rules()  # For demonstration
    
    def setup_ui(self):
        """Setup rule matrix UI"""
        
        # Main container
        main_container = ctk.CTkFrame(self, fg_color="transparent")
        main_container.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Top section: Controls and mode toggle
        top_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        top_frame.pack(fill="x", pady=(0, 10))
        
        # Left side: mode toggle
        mode_frame = ctk.CTkFrame(top_frame, fg_color="transparent")
        mode_frame.pack(side="left")
        
        mode_label = ctk.CTkLabel(
            mode_frame,
            text="View Mode:",
            font=ctk.CTkFont(family="Arial", size=12),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        mode_label.pack(side="left", padx=(0, 10))
        
        self.mode_switch = ctk.CTkSwitch(
            mode_frame,
            text="Advanced",
            command=self.toggle_mode,
            font=ctk.CTkFont(family="Arial", size=11)
        )
        self.mode_switch.pack(side="left")
        
        # Right side: action buttons
        actions_frame = ctk.CTkFrame(top_frame, fg_color="transparent")
        actions_frame.pack(side="right")
        
        new_rule_button = ctk.CTkButton(
            actions_frame,
            text="➕ New Rule",
            font=ctk.CTkFont(family="Arial", size=12),
            width=100,
            command=self.create_new_rule
        )
        new_rule_button.pack(side="left", padx=(0, 10))
        
        import_button = ctk.CTkButton(
            actions_frame,
            text="📁 Import",
            font=ctk.CTkFont(family="Arial", size=12),
            width=80,
            command=self.import_rules
        )
        import_button.pack(side="left", padx=(0, 10))
        
        export_button = ctk.CTkButton(
            actions_frame,
            text="📤 Export",
            font=ctk.CTkFont(family="Arial", size=12),
            width=80,
            command=self.export_rules
        )
        export_button.pack(side="left")
        
        # Content area with splitter
        content_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        content_frame.pack(fill="both", expand=True)
        
        # Configure for resizable panes
        content_frame.grid_columnconfigure(0, weight=1)
        content_frame.grid_rowconfigure(0, weight=1)
        
        # Main content (left side)
        self.main_content = ctk.CTkFrame(content_frame, fg_color="transparent")
        self.main_content.grid(row=0, column=0, sticky="nsew", padx=(0, 5))
        
        # Setup mode-specific content
        self.setup_simple_mode()
        self.setup_advanced_mode()
        
        # What-if simulator (right side, initially hidden)
        self.simulator = WhatIfSimulatorDrawer(content_frame)
        self.simulator.on_apply_rule = self.on_rule_applied
        # Don't grid initially - will be shown when needed
    
    def setup_simple_mode(self):
        """Setup simple mode interface"""
        
        self.simple_frame = ctk.CTkFrame(self.main_content, fg_color="transparent")
        
        # Simple rules table
        simple_title = ctk.CTkLabel(
            self.simple_frame,
            text="Trading Rules (Simple View)",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        simple_title.pack(anchor="w", pady=(0, 10))
        
        # Simple table columns
        simple_columns = ["Rule Name", "Confidence", "Win Rate", "Status", "Actions"]
        
        self.simple_table = AdvancedTableWidget(
            self.simple_frame,
            title="",
            columns=simple_columns
        )
        self.simple_table.pack(fill="both", expand=True)
        
        # Bind double-click for what-if
        self.simple_table.tree.bind("<Double-1>", self.on_simple_rule_double_click)
        
        # Show simple mode by default
        self.simple_frame.pack(fill="both", expand=True)
    
    def setup_advanced_mode(self):
        """Setup advanced mode interface"""
        
        self.advanced_frame = ctk.CTkFrame(self.main_content, fg_color="transparent")
        
        # Advanced mode header
        advanced_header = ctk.CTkFrame(self.advanced_frame, fg_color="transparent")
        advanced_header.pack(fill="x", pady=(0, 10))
        
        advanced_title = ctk.CTkLabel(
            advanced_header,
            text="Rule Matrix (Advanced View)",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        advanced_title.pack(side="left")
        
        # View toggle buttons
        view_frame = ctk.CTkFrame(advanced_header, fg_color="transparent")
        view_frame.pack(side="right")
        
        table_view_button = ctk.CTkButton(
            view_frame,
            text="📋 Table",
            font=ctk.CTkFont(family="Arial", size=10),
            width=70,
            height=30,
            command=lambda: self.switch_advanced_view("table")
        )
        table_view_button.pack(side="left", padx=(0, 5))
        
        heatmap_view_button = ctk.CTkButton(
            view_frame,
            text="🔥 Heatmap",
            font=ctk.CTkFont(family="Arial", size=10),
            width=80,
            height=30,
            command=lambda: self.switch_advanced_view("heatmap")
        )
        heatmap_view_button.pack(side="left")
        
        # Advanced content stack
        self.advanced_stack = ctk.CTkFrame(self.advanced_frame, fg_color="transparent")
        self.advanced_stack.pack(fill="both", expand=True)
        
        # Advanced table view
        self.advanced_table_frame = ctk.CTkFrame(self.advanced_stack, fg_color="transparent")
        
        advanced_columns = [
            "Rule Name", "Conditions", "Action", "Confidence", 
            "Sample Size", "Win Rate", "Expected Return", "Last Triggered"
        ]
        
        self.advanced_table = AdvancedTableWidget(
            self.advanced_table_frame,
            title="",
            columns=advanced_columns
        )
        self.advanced_table.pack(fill="both", expand=True)
        
        # Bind events
        self.advanced_table.tree.bind("<Double-1>", self.on_advanced_rule_double_click)
        
        # Heatmap view
        self.heatmap_frame = ctk.CTkFrame(self.advanced_stack, fg_color="transparent")
        
        heatmap_title = ctk.CTkLabel(
            self.heatmap_frame,
            text="Rule Confidence Heatmap",
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        heatmap_title.pack(anchor="w", pady=(0, 10))
        
        self.confidence_heatmap = ConfidenceHeatmapWidget(
            self.heatmap_frame,
            width=600,
            height=400
        )
        self.confidence_heatmap.pack(fill="both", expand=True, pady=10)
        self.confidence_heatmap.on_cell_clicked = self.on_heatmap_cell_clicked
        
        # Show table view by default
        self.current_advanced_view = "table"
        self.advanced_table_frame.pack(fill="both", expand=True)
        
        # Don't pack advanced frame initially
    
    def setup_event_handlers(self):
        """Setup event handlers"""
        
        event_bus.subscribe("rule_matrix_update", self._handle_rule_update)
        event_bus.subscribe("apply_rule_to_ticket", self._handle_rule_application)
    
    def _handle_rule_update(self, event):
        """Handle rule update events"""
        data = event.data
        
        # Update rules based on event data
        # Implementation would depend on your specific rule data format
        self.refresh_display()
    
    def _handle_rule_application(self, event):
        """Handle rule application events"""
        data = event.data
        
        rule_name = data.get('rule_name', 'Unknown')
        show_info(f"Rule '{rule_name}' has been applied")
    
    def toggle_mode(self):
        """Toggle between simple and advanced modes"""
        
        self.simple_mode = not self.simple_mode
        
        if self.simple_mode:
            # Switch to simple mode
            self.advanced_frame.pack_forget()
            self.simple_frame.pack(fill="both", expand=True)
            self.mode_switch.deselect()
        else:
            # Switch to advanced mode
            self.simple_frame.pack_forget()
            self.advanced_frame.pack(fill="both", expand=True)
            self.mode_switch.select()
        
        # Update content
        self.refresh_display()
    
    def switch_advanced_view(self, view_type: str):
        """Switch between advanced view types"""
        
        if view_type == "table":
            self.heatmap_frame.pack_forget()
            self.advanced_table_frame.pack(fill="both", expand=True)
        elif view_type == "heatmap":
            self.advanced_table_frame.pack_forget()
            self.heatmap_frame.pack(fill="both", expand=True)
            # Update heatmap data
            self.confidence_heatmap.update_rules(self.filtered_rules)
        
        self.current_advanced_view = view_type
    
    def on_simple_rule_double_click(self, event):
        """Handle double-click in simple table"""
        
        selection = self.simple_table.tree.selection()
        if not selection:
            return
        
        item = selection[0]
        rule_name = self.simple_table.tree.set(item, "Rule Name")
        
        # Find rule
        rule = next((r for r in self.rules if r.name == rule_name), None)
        if rule:
            self.show_what_if_simulator(rule)
    
    def on_advanced_rule_double_click(self, event):
        """Handle double-click in advanced table"""
        
        selection = self.advanced_table.tree.selection()
        if not selection:
            return
        
        item = selection[0]
        rule_name = self.advanced_table.tree.set(item, "Rule Name")
        
        # Find rule
        rule = next((r for r in self.rules if r.name == rule_name), None)
        if rule:
            self.show_what_if_simulator(rule)
    
    def on_heatmap_cell_clicked(self, rule: MatrixRule):
        """Handle heatmap cell click"""
        self.show_what_if_simulator(rule)
    
    def show_what_if_simulator(self, rule: MatrixRule):
        """Show what-if simulator for rule"""
        
        if not self.simulator_visible:
            # Show simulator
            self.main_content.grid_configure(column=0, padx=(0, 5))
            self.simulator.grid(row=0, column=1, sticky="nsew", padx=(5, 0))
            
            # Adjust column weights
            content_frame = self.simulator.master
            content_frame.grid_columnconfigure(1, weight=0, minsize=400)
            
            self.simulator_visible = True
        
        # Load rule into simulator
        self.simulator.show_rule(rule)
    
    def hide_what_if_simulator(self):
        """Hide what-if simulator"""
        
        if self.simulator_visible:
            self.simulator.grid_forget()
            self.main_content.grid_configure(column=0, padx=0)
            
            # Reset column weights
            content_frame = self.simulator.master
            content_frame.grid_columnconfigure(1, weight=0, minsize=0)
            
            self.simulator_visible = False
    
    def on_rule_applied(self, rule: MatrixRule):
        """Handle rule application from simulator"""
        
        # Hide simulator after successful application
        self.hide_what_if_simulator()
        
        # Update rule last triggered time
        rule.last_triggered = datetime.now()
        
        # Refresh display
        self.refresh_display()
    
    def create_new_rule(self):
        """Create new rule dialog"""
        
        # Create new rule window
        new_rule_window = ctk.CTkToplevel(self)
        new_rule_window.title("Create New Rule")
        new_rule_window.geometry("600x500")
        new_rule_window.configure(fg_color=ColorPalette.DARK_SURFACE)
        
        # Make modal
        new_rule_window.transient(self)
        new_rule_window.grab_set()
        
        # Implementation of rule creation form would go here
        # For now, just show placeholder
        
        placeholder_label = ctk.CTkLabel(
            new_rule_window,
            text="Rule Creation Form\n\n(Implementation pending)",
            font=ctk.CTkFont(family="Arial", size=14),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        )
        placeholder_label.pack(expand=True)
        
        close_button = ctk.CTkButton(
            new_rule_window,
            text="Close",
            command=new_rule_window.destroy
        )
        close_button.pack(pady=20)
    
    def import_rules(self):
        """Import rules from file"""
        
        try:
            from tkinter import filedialog
            
            filename = filedialog.askopenfilename(
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
                title="Import Rules"
            )
            
            if not filename:
                return
            
            with open(filename, 'r') as f:
                rules_data = json.load(f)
            
            # Convert to MatrixRule objects
            imported_rules = []
            for rule_data in rules_data:
                rule = MatrixRule(
                    rule_id=rule_data['rule_id'],
                    name=rule_data['name'],
                    conditions=[],  # Would parse conditions
                    action=RuleAction("", {}),  # Would parse action
                    confidence=rule_data.get('confidence', 0.0),
                    sample_size=rule_data.get('sample_size', 0),
                    expected_return=rule_data.get('RetryDContinueEditMapped out implementation roadmap for rule matrix functionality.The user wants me to continue with the implementation guide. I was in the middle of implementing the rule matrix tab, specifically the import_rules method. I need to complete that method and then continue with the remaining phases of the implementation guide (Phase 7-10).
Looking at where I left off, I was in the middle of the import_rules method in the RuleMatrixTab class. I need to:

Complete the import_rules method
Implement the export_rules method
Add the load_sample_rules method
Complete the refresh_display method
Add the integration function
Then move on to Phase 7: Readiness Card implementation
Phase 8: Performance optimizations
Phase 9: Final integration
Phase 10: Testing and deployment
python                    expected_return=rule_data.get('expected_return', 0.0),
                    win_rate=rule_data.get('win_rate', 0.0),
                    avg_duration=rule_data.get('avg_duration', 0.0),
                    last_triggered=datetime.fromisoformat(rule_data['last_triggered']) if rule_data.get('last_triggered') else None,
                    enabled=rule_data.get('enabled', True),
                    tags=rule_data.get('tags', [])
                )
                imported_rules.append(rule)
            
            # Add to existing rules
            self.rules.extend(imported_rules)
            self.refresh_display()
            
            show_success(f"Imported {len(imported_rules)} rules from {filename}")
            
        except Exception as e:
            show_warning(f"Import failed: {e}")
    
    def export_rules(self):
        """Export rules to file"""
        
        try:
            from tkinter import filedialog
            
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
                title="Export Rules"
            )
            
            if not filename:
                return
            
            # Convert rules to serializable format
            rules_data = []
            for rule in self.rules:
                rule_data = asdict(rule)
                # Handle datetime serialization
                if rule_data['last_triggered']:
                    rule_data['last_triggered'] = rule.last_triggered.isoformat()
                rules_data.append(rule_data)
            
            with open(filename, 'w') as f:
                json.dump(rules_data, f, indent=2, default=str)
            
            show_success(f"Exported {len(self.rules)} rules to {filename}")
            
        except Exception as e:
            show_warning(f"Export failed: {e}")
    
    def load_sample_rules(self):
        """Load sample rules for demonstration"""
        
        sample_rules = [
            MatrixRule(
                rule_id="rule_001",
                name="EURUSD Breakout",
                conditions=[
                    RuleCondition("timeframe", "==", "15m"),
                    RuleCondition("volatility", ">", 0.8),
                    RuleCondition("strength_eur", ">", 0.6)
                ],
                action=RuleAction("buy_stop", {"distance_pips": 15}),
                confidence=0.75,
                sample_size=45,
                expected_return=25.5,
                win_rate=0.68,
                avg_duration=2.5,
                last_triggered=datetime.now() - timedelta(hours=2),
                enabled=True,
                tags=["breakout", "eur"]
            ),
            MatrixRule(
                rule_id="rule_002", 
                name="GBPJPY Reversal",
                conditions=[
                    RuleCondition("rsi", "<", 30),
                    RuleCondition("support_level", "near", True),
                    RuleCondition("correlation_gbp_jpy", "<", 0.3)
                ],
                action=RuleAction("buy_limit", {"distance_pips": 10}),
                confidence=0.82,
                sample_size=67,
                expected_return=35.2,
                win_rate=0.71,
                avg_duration=4.2,
                last_triggered=datetime.now() - timedelta(minutes=45),
                enabled=True,
                tags=["reversal", "gbp", "jpy"]
            ),
            MatrixRule(
                rule_id="rule_003",
                name="USD Strength Play",
                conditions=[
                    RuleCondition("strength_usd", ">", 0.8),
                    RuleCondition("news_impact", "==", "high"),
                    RuleCondition("session", "==", "london")
                ],
                action=RuleAction("market_buy", {"symbol": "auto"}),
                confidence=0.65,
                sample_size=23,
                expected_return=18.7,
                win_rate=0.61,
                avg_duration=1.8,
                last_triggered=None,
                enabled=False,
                tags=["strength", "usd", "news"]
            )
        ]
        
        self.rules.extend(sample_rules)
        self.refresh_display()
    
    def refresh_display(self):
        """Refresh all display elements"""
        
        with self.update_lock:
            # Apply any filters (simplified - no filters implemented yet)
            self.filtered_rules = [rule for rule in self.rules if rule.enabled]
            
            if self.simple_mode:
                self.update_simple_table()
            else:
                if self.current_advanced_view == "table":
                    self.update_advanced_table()
                elif self.current_advanced_view == "heatmap":
                    self.confidence_heatmap.update_rules(self.filtered_rules)
    
    def update_simple_table(self):
        """Update simple mode table"""
        
        rows = []
        for rule in self.filtered_rules:
            row = {
                "name": rule.name,
                "rule_name": rule.name,
                "confidence": f"{rule.confidence:.1%}",
                "win_rate": f"{rule.win_rate:.1%}",
                "status": "Active" if rule.enabled else "Disabled",
                "actions": "📊 Simulate"
            }
            rows.append(row)
        
        self.simple_table.update_rows(rows)
    
    def update_advanced_table(self):
        """Update advanced mode table"""
        
        rows = []
        for rule in self.filtered_rules:
            # Format conditions
            conditions_text = ", ".join([
                f"{c.parameter} {c.operator} {c.value}" 
                for c in rule.conditions[:2]  # Show first 2 conditions
            ])
            if len(rule.conditions) > 2:
                conditions_text += "..."
            
            # Format action
            action_text = f"{rule.action.action_type}"
            if rule.action.parameters:
                first_param = next(iter(rule.action.parameters.items()), ("", ""))
                action_text += f" ({first_param[0]}: {first_param[1]})"
            
            # Format last triggered
            if rule.last_triggered:
                time_diff = datetime.now() - rule.last_triggered
                if time_diff.total_seconds() < 3600:
                    triggered_text = f"{int(time_diff.total_seconds() / 60)}m ago"
                elif time_diff.total_seconds() < 86400:
                    triggered_text = f"{int(time_diff.total_seconds() / 3600)}h ago"
                else:
                    triggered_text = f"{int(time_diff.total_seconds() / 86400)}d ago"
            else:
                triggered_text = "Never"
            
            row = {
                "name": rule.name,
                "rule_name": rule.name,
                "conditions": conditions_text,
                "action": action_text,
                "confidence": f"{rule.confidence:.1%}",
                "sample_size": str(rule.sample_size),
                "win_rate": f"{rule.win_rate:.1%}",
                "expected_return": f"{rule.expected_return:.1f} pips",
                "last_triggered": triggered_text
            }
            rows.append(row)
        
        self.advanced_table.update_rows(rows)

# Integration function for main application
def integrate_rule_matrix_tab(notebook_widget) -> RuleMatrixTab:
    """
    Integration function to add rule matrix tab to main notebook
    
    Args:
        notebook_widget: CTkTabview or similar notebook widget
        
    Returns:
        RuleMatrixTab instance
    """
    
    rule_matrix_tab = RuleMatrixTab(notebook_widget)
    
    # Add to notebook (assuming CTkTabview)
    if hasattr(notebook_widget, 'add'):
        notebook_widget.add("🧩 Rule Matrix")
        tab_frame = notebook_widget.tab("🧩 Rule Matrix")
        rule_matrix_tab.pack(fill="both", expand=True)
    
    return rule_matrix_tab

🎯 PHASE 7: READINESS & QUALITY-GATES CARD (Day 6)
Step 7.1: Readiness Card Implementation
File: src/ui/readiness_card.py
python"""
Readiness & Quality-Gates Card - Trading system health and constraint monitoring
"""

import customtkinter as ctk
import tkinter as tk
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import threading
import math

from ..core.event_bus import event_bus
from ..core.state_manager import state_manager
from ..themes.colors import ColorPalette, get_risk_color, interpolate_color
from .modern_widgets import ColoredProgressBar
from .toast_manager import show_info, show_warning

class ConstraintStatus(Enum):
    PASSED = "PASSED"
    WARNING = "WARNING" 
    FAILED = "FAILED"
    UNKNOWN = "UNKNOWN"

@dataclass
class Constraint:
    """Individual constraint definition"""
    key: str
    name: str
    description: str
    category: str
    current_value: Any
    expected_value: Any
    operator: str  # ">=", "<=", "==", "!=", "in", "not_in"
    status: ConstraintStatus
    severity: str  # "critical", "warning", "info"
    fix_action: str
    last_checked: datetime

@dataclass
class QualityGateCategory:
    """Quality gate category with constraints"""
    name: str
    description: str
    constraints: List[Constraint] = field(default_factory=list)
    weight: float = 1.0
    
    @property
    def score(self) -> float:
        """Calculate category score (0-100)"""
        if not self.constraints:
            return 100.0
        
        passed_count = sum(1 for c in self.constraints if c.status == ConstraintStatus.PASSED)
        return (passed_count / len(self.constraints)) * 100.0
    
    @property
    def status(self) -> ConstraintStatus:
        """Get overall category status"""
        if not self.constraints:
            return ConstraintStatus.UNKNOWN
        
        if any(c.status == ConstraintStatus.FAILED and c.severity == "critical" for c in self.constraints):
            return ConstraintStatus.FAILED
        elif any(c.status == ConstraintStatus.FAILED for c in self.constraints):
            return ConstraintStatus.WARNING
        elif all(c.status == ConstraintStatus.PASSED for c in self.constraints):
            return ConstraintStatus.PASSED
        else:
            return ConstraintStatus.WARNING

class ConstraintViolationWidget(ctk.CTkFrame):
    """Widget to display individual constraint violation"""
    
    def __init__(self, master, constraint: Constraint, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE_VARIANT,
            "border_width": 1,
            "corner_radius": 6,
            "height": 60
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.constraint = constraint
        self.pack_propagate(False)
        
        # Set border color based on severity
        border_colors = {
            "critical": ColorPalette.DANGER,
            "warning": ColorPalette.WARNING,
            "info": ColorPalette.INFO
        }
        self.configure(border_color=border_colors.get(constraint.severity, ColorPalette.DARK_BORDER))
        
        self.setup_ui()
    
    def setup_ui(self):
        """Setup constraint violation UI"""
        
        # Main content frame
        content_frame = ctk.CTkFrame(self, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=8, pady=6)
        
        # Left side: severity indicator and name
        left_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        left_frame.pack(side="left", fill="both", expand=True)
        
        # Top row: severity icon and name
        top_row = ctk.CTkFrame(left_frame, fg_color="transparent")
        top_row.pack(fill="x")
        
        # Severity icon
        severity_icons = {
            "critical": "🔴",
            "warning": "🟡", 
            "info": "🔵"
        }
        
        severity_icon = ctk.CTkLabel(
            top_row,
            text=severity_icons.get(self.constraint.severity, "⚪"),
            font=ctk.CTkFont(family="Arial", size=14),
            width=20
        )
        severity_icon.pack(side="left", padx=(0, 5))
        
        # Constraint name
        name_label = ctk.CTkLabel(
            top_row,
            text=self.constraint.name,
            font=ctk.CTkFont(family="Arial", size=11, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            anchor="w"
        )
        name_label.pack(side="left", fill="x", expand=True)
        
        # Bottom row: current vs expected values
        bottom_row = ctk.CTkFrame(left_frame, fg_color="transparent")
        bottom_row.pack(fill="x", pady=(2, 0))
        
        values_text = f"Current: {self.constraint.current_value} | Expected: {self.constraint.expected_value}"
        values_label = ctk.CTkLabel(
            bottom_row,
            text=values_text,
            font=ctk.CTkFont(family="Arial", size=9),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            anchor="w"
        )
        values_label.pack(side="left", fill="x", expand=True)
        
        # Right side: fix action button
        if self.constraint.fix_action and self.constraint.fix_action != "None":
            fix_button = ctk.CTkButton(
                content_frame,
                text="🔧 Fix",
                font=ctk.CTkFont(family="Arial", size=9),
                width=50,
                height=25,
                command=self.execute_fix_action
            )
            fix_button.pack(side="right", padx=(5, 0))
    
    def execute_fix_action(self):
        """Execute the fix action for this constraint"""
        
        try:
            # Publish fix action event
            event_bus.publish(
                "execute_constraint_fix",
                {
                    "constraint_key": self.constraint.key,
                    "fix_action": self.constraint.fix_action,
                    "timestamp": datetime.now().isoformat()
                },
                source="readiness_card"
            )
            
            show_info(f"Executing fix: {self.constraint.fix_action}")
            
        except Exception as e:
            show_warning(f"Failed to execute fix: {e}")

class QualityGateCategoryWidget(ctk.CTkFrame):
    """Widget for displaying quality gate category"""
    
    def __init__(self, master, category: QualityGateCategory, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE_VARIANT,
            "border_width": 1,
            "border_color": ColorPalette.DARK_BORDER,
            "corner_radius": 8
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.category = category
        self.expanded = False
        
        self.setup_ui()
        self.update_display()
    
    def setup_ui(self):
        """Setup category widget UI"""
        
        # Header (always visible)
        self.header_frame = ctk.CTkFrame(self, fg_color="transparent", height=50)
        self.header_frame.pack(fill="x", padx=8, pady=8)
        self.header_frame.pack_propagate(False)
        
        # Left side: expand button and name
        left_frame = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        left_frame.pack(side="left", fill="both", expand=True)
        
        # Expand/collapse button
        self.expand_button = ctk.CTkButton(
            left_frame,
            text="▶",
            font=ctk.CTkFont(family="Arial", size=12),
            width=25,
            height=25,
            fg_color="transparent",
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            hover_color=ColorPalette.DARK_SURFACE,
            command=self.toggle_expansion
        )
        self.expand_button.pack(side="left", padx=(0, 10))
        
        # Category info
        info_frame = ctk.CTkFrame(left_frame, fg_color="transparent")
        info_frame.pack(side="left", fill="both", expand=True)
        
        # Category name
        self.name_label = ctk.CTkLabel(
            info_frame,
            text=self.category.name,
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY,
            anchor="w"
        )
        self.name_label.pack(anchor="w")
        
        # Category description
        self.desc_label = ctk.CTkLabel(
            info_frame,
            text=self.category.description,
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY,
            anchor="w"
        )
        self.desc_label.pack(anchor="w", pady=(2, 0))
        
        # Right side: score and status
        right_frame = ctk.CTkFrame(self.header_frame, fg_color="transparent", width=120)
        right_frame.pack(side="right", fill="y")
        right_frame.pack_propagate(False)
        
        # Score display
        score_frame = ctk.CTkFrame(right_frame, fg_color="transparent")
        score_frame.pack(fill="x")
        
        self.score_label = ctk.CTkLabel(
            score_frame,
            text="100%",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold"),
            text_color=ColorPalette.SUCCESS
        )
        self.score_label.pack(side="right")
        
        ctk.CTkLabel(
            score_frame,
            text="Score:",
            font=ctk.CTkFont(family="Arial", size=10),
            text_color=ColorPalette.DARK_TEXT_SECONDARY
        ).pack(side="right", padx=(0, 5))
        
        # Progress bar
        self.progress_bar = ColoredProgressBar(
            right_frame,
            width=100,
            height=6
        )
        self.progress_bar.pack(fill="x", pady=(5, 0))
        
        # Expandable content (violations)
        self.content_frame = ctk.CTkFrame(self, fg_color="transparent")
        # Don't pack initially - will be shown when expanded
        
        self.violations_container = ctk.CTkScrollableFrame(
            self.content_frame,
            fg_color=ColorPalette.DARK_SURFACE,
            height=150
        )
        self.violations_container.pack(fill="both", expand=True, padx=8, pady=(0, 8))
    
    def toggle_expansion(self):
        """Toggle category expansion"""
        
        self.expanded = not self.expanded
        
        if self.expanded:
            # Expand
            self.expand_button.configure(text="▼")
            self.content_frame.pack(fill="both", expand=True, pady=(0, 8))
            self.update_violations_display()
        else:
            # Collapse
            self.expand_button.configure(text="▶")
            self.content_frame.pack_forget()
    
    def update_display(self):
        """Update category display"""
        
        score = self.category.score
        status = self.category.status
        
        # Update score
        self.score_label.configure(text=f"{score:.0f}%")
        self.progress_bar.set_value_with_color(score, 100.0)
        
        # Update score color based on status
        status_colors = {
            ConstraintStatus.PASSED: ColorPalette.SUCCESS,
            ConstraintStatus.WARNING: ColorPalette.WARNING,
            ConstraintStatus.FAILED: ColorPalette.DANGER,
            ConstraintStatus.UNKNOWN: ColorPalette.DARK_TEXT_SECONDARY
        }
        
        self.score_label.configure(text_color=status_colors.get(status, ColorPalette.DARK_TEXT_PRIMARY))
        
        # Update violations if expanded
        if self.expanded:
            self.update_violations_display()
    
    def update_violations_display(self):
        """Update violations display in expanded content"""
        
        # Clear existing violations
        for widget in self.violations_container.winfo_children():
            widget.destroy()
        
        # Show failed constraints
        failed_constraints = [c for c in self.category.constraints 
                            if c.status != ConstraintStatus.PASSED]
        
        if not failed_constraints:
            # No violations
            no_violations_label = ctk.CTkLabel(
                self.violations_container,
                text="✅ All constraints passed",
                font=ctk.CTkFont(family="Arial", size=11),
                text_color=ColorPalette.SUCCESS
            )
            no_violations_label.pack(pady=20)
        else:
            # Show violations
            for constraint in failed_constraints:
                violation_widget = ConstraintViolationWidget(
                    self.violations_container,
                    constraint
                )
                violation_widget.pack(fill="x", pady=2)

class ReadinessScoreWidget(ctk.CTkFrame):
    """Main readiness score display widget"""
    
    def __init__(self, master, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE_VARIANT,
            "border_width": 2,
            "corner_radius": 12
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        self.overall_score = 100.0
        self.setup_ui()
    
    def setup_ui(self):
        """Setup readiness score UI"""
        
        # Title
        title_label = ctk.CTkLabel(
            self,
            text="Trading Readiness Score",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        title_label.pack(pady=(15, 5))
        
        # Main score display
        score_frame = ctk.CTkFrame(self, fg_color="transparent")
        score_frame.pack(pady=10)
        
        # Circular progress indicator (simplified as text for now)
        self.score_circle_frame = ctk.CTkFrame(
            score_frame,
            fg_color=ColorPalette.DARK_SURFACE,
            corner_radius=50,
            width=100,
            height=100
        )
        self.score_circle_frame.pack()
        self.score_circle_frame.pack_propagate(False)
        
        self.score_label = ctk.CTkLabel(
            self.score_circle_frame,
            text="100",
            font=ctk.CTkFont(family="Arial", size=24, weight="bold"),
            text_color=ColorPalette.SUCCESS
        )
        self.score_label.pack(expand=True)
        
        # Score description
        self.status_label = ctk.CTkLabel(
            self,
            text="System Ready",
            font=ctk.CTkFont(family="Arial", size=12),
            text_color=ColorPalette.SUCCESS
        )
        self.status_label.pack(pady=(5, 15))
    
    def update_score(self, score: float):
        """Update readiness score display"""
        
        self.overall_score = score
        
        # Update score text
        self.score_label.configure(text=f"{score:.0f}")
        
        # Update colors based on score
        if score >= 90:
            score_color = ColorPalette.SUCCESS
            status_text = "System Ready"
            border_color = ColorPalette.SUCCESS
        elif score >= 70:
            score_color = ColorPalette.WARNING
            status_text = "Minor Issues"
            border_color = ColorPalette.WARNING
        elif score >= 50:
            score_color = ColorPalette.WARNING
            status_text = "Significant Issues"
            border_color = ColorPalette.WARNING
        else:
            score_color = ColorPalette.DANGER
            status_text = "System Not Ready"
            border_color = ColorPalette.DANGER
        
        self.score_label.configure(text_color=score_color)
        self.status_label.configure(text=status_text, text_color=score_color)
        self.configure(border_color=border_color)

class ReadinessCard(ctk.CTkFrame):
    """Main readiness and quality gates card"""
    
    def __init__(self, master, **kwargs):
        
        default_kwargs = {
            "fg_color": ColorPalette.DARK_SURFACE,
            "corner_radius": 8
        }
        default_kwargs.update(kwargs)
        
        super().__init__(master, **default_kwargs)
        
        # Data storage
        self.categories: Dict[str, QualityGateCategory] = {}
        self.update_lock = threading.Lock()
        self.last_update = datetime.now()
        
        # UI state
        self.auto_refresh = True
        self.refresh_interval = 5.0  # seconds
        
        self.setup_ui()
        self.setup_event_handlers()
        self.initialize_constraints()
        self.start_update_loop()
    
    def setup_ui(self):
        """Setup readiness card UI"""
        
        # Header
        header_frame = ctk.CTkFrame(self, fg_color="transparent")
        header_frame.pack(fill="x", padx=10, pady=(10, 5))
        
        title_label = ctk.CTkLabel(
            header_frame,
            text="System Readiness & Quality Gates",
            font=ctk.CTkFont(family="Arial", size=16, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        title_label.pack(side="left")
        
        # Controls
        controls_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        controls_frame.pack(side="right")
        
        refresh_button = ctk.CTkButton(
            controls_frame,
            text="🔄",
            font=ctk.CTkFont(family="Arial", size=12),
            width=30,
            height=30,
            command=self.force_refresh
        )
        refresh_button.pack(side="left", padx=(0, 5))
        
        auto_refresh_switch = ctk.CTkSwitch(
            controls_frame,
            text="Auto",
            font=ctk.CTkFont(family="Arial", size=10),
            width=50,
            command=self.toggle_auto_refresh
        )
        auto_refresh_switch.pack(side="left")
        auto_refresh_switch.select()  # Default to enabled
        
        # Main content area
        content_frame = ctk.CTkFrame(self, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        # Left side: Overall score
        left_frame = ctk.CTkFrame(content_frame, fg_color="transparent", width=200)
        left_frame.pack(side="left", fill="y", padx=(0, 10))
        left_frame.pack_propagate(False)
        
        self.readiness_score = ReadinessScoreWidget(left_frame)
        self.readiness_score.pack(fill="both", expand=True)
        
        # Right side: Categories
        right_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        right_frame.pack(side="right", fill="both", expand=True)
        
        categories_title = ctk.CTkLabel(
            right_frame,
            text="Quality Gate Categories",
            font=ctk.CTkFont(family="Arial", size=12, weight="bold"),
            text_color=ColorPalette.DARK_TEXT_PRIMARY
        )
        categories_title.pack(anchor="w", pady=(0, 10))
        
        self.categories_container = ctk.CTkScrollableFrame(
            right_frame,
            fg_color=ColorPalette.DARK_SURFACE,
            scrollbar_button_color=ColorPalette.DARK_BORDER,
            scrollbar_button_hover_color=ColorPalette.INFO
        )
        self.categories_container.pack(fill="both", expand=True)
    
    def setup_event_handlers(self):
        """Setup event handlers"""
        
        event_bus.subscribe("constraint_update", self._handle_constraint_update)
        event_bus.subscribe("system_health_update", self._handle_system_health_update)
        event_bus.subscribe("execute_constraint_fix", self._handle_constraint_fix)
    
    def _handle_constraint_update(self, event):
        """Handle constraint update events"""
        data = event.data
        
        constraint_key = data.get('constraint_key')
        if constraint_key and constraint_key in self._get_all_constraints():
            # Update specific constraint
            self.update_constraint(constraint_key, data)
    
    def _handle_system_health_update(self, event):
        """Handle system health update events"""
        # Trigger full refresh when system health changes
        self.check_all_constraints()
    
    def _handle_constraint_fix(self, event):
        """Handle constraint fix execution"""
        data = event.data
        
        constraint_key = data.get('constraint_key')
        fix_action = data.get('fix_action')
        
        # Execute fix based on action type
        self.execute_fix_action(constraint_key, fix_action)
    
    def initialize_constraints(self):
        """Initialize quality gate constraints"""
        
        # Market Quality constraints
        market_constraints = [
            Constraint(
                key="dde_connection",
                name="DDE Connection",
                description="MetaTrader 4 DDE connection status",
                category="Market Quality",
                current_value=True,
                expected_value=True,
                operator="==",
                status=ConstraintStatus.PASSED,
                severity="critical",
                fix_action="Reconnect DDE",
                last_checked=datetime.now()
            ),
            Constraint(
                key="symbol_count",
                name="Symbol Count", 
                description="Number of active currency pairs",
                category="Market Quality",
                current_value=8,
                expected_value=5,
                operator=">=",
                status=ConstraintStatus.PASSED,
                severity="warning",
                fix_action="Add more symbols",
                last_checked=datetime.now()
            ),
            Constraint(
                key="data_freshness",
                name="Data Freshness",
                description="Age of latest market data",
                category="Market Quality",
                current_value=5,
                expected_value=30,
                operator="<=",
                status=ConstraintStatus.PASSED,
                severity="critical",
                fix_action="Refresh data feed",
                last_checked=datetime.now()
            )
        ]
        
        # Risk Management constraints
        risk_constraints = [
            Constraint(
                key="daily_risk_limit",
                name="Daily Risk Limit",
                description="Daily drawdown within acceptable range",
                category="Risk Management",
                current_value=1.2,
                expected_value=2.0,
                operator="<=",
                status=ConstraintStatus.PASSED,
                severity="critical",
                fix_action="Reduce position sizes",
                last_checked=datetime.now()
            ),
            Constraint(
                key="correlation_limit",
                name="Correlation Limit",
                description="Maximum correlation between positions",
                category="Risk Management",
                current_value=0.65,
                expected_value=0.70,
                operator="<=",
                status=ConstraintStatus.PASSED,
                severity="warning",
                fix_action="Diversify positions",
                last_checked=datetime.now()
            ),
            Constraint(
                key="portfolio_risk",
                name="Portfolio Risk",
                description="Total portfolio risk exposure",
                category="Risk Management", 
                current_value=2.1,
                expected_value=3.0,
                operator="<=",
                status=ConstraintStatus.PASSED,
                severity="warning",
                fix_action="Lower risk per trade",
                last_checked=datetime.now()
            )
        ]
        
        # System Health constraints
        system_constraints = [
            Constraint(
                key="cpu_usage",
                name="CPU Usage",
                description="System CPU utilization",
                category="System Health",
                current_value=45,
                expected_value=80,
                operator="<=",
                status=ConstraintStatus.PASSED,
                severity="warning",
                fix_action="Close unnecessary programs",
                last_checked=datetime.now()
            ),
            Constraint(
                key="memory_usage",
                name="Memory Usage", 
                description="System memory utilization",
                category="System Health",
                current_value=67,
                expected_value=85,
                operator="<=",
                status=ConstraintStatus.PASSED,
                severity="warning",
                fix_action="Restart application",
                last_checked=datetime.now()
            ),
            Constraint(
                key="event_queue_size",
                name="Event Queue Size",
                description="Number of pending events",
                category="System Health",
                current_value=3,
                expected_value=50,
                operator="<=",
                status=ConstraintStatus.PASSED,
                severity="info",
                fix_action="Process event backlog",
                last_checked=datetime.now()
            )
        ]
        
        # Connectivity constraints
        connectivity_constraints = [
            Constraint(
                key="internet_connection",
                name="Internet Connection",
                description="Internet connectivity status",
                category="Connectivity",
                current_value=True,
                expected_value=True,
                operator="==",
                status=ConstraintStatus.PASSED,
                severity="critical",
                fix_action="Check network connection",
                last_checked=datetime.now()
            ),
            Constraint(
                key="broker_connection",
                name="Broker Connection",
                description="Connection to trading broker",
                category="Connectivity",
                current_value=True,
                expected_value=True,
                operator="==",
                status=ConstraintStatus.PASSED,
                severity="critical",
                fix_action="Reconnect to broker",
                last_checked=datetime.now()
            )
        ]
        
        # Create categories
        self.categories = {
            "Market Quality": QualityGateCategory(
                name="Market Quality",
                description="Data feed quality and availability",
                constraints=market_constraints,
                weight=1.5
            ),
            "Risk Management": QualityGateCategory(
                name="Risk Management",
                description="Risk limits and portfolio health",
                constraints=risk_constraints,
                weight=2.0
            ),
            "System Health": QualityGateCategory(
                name="System Health",
                description="Application performance and stability",
                constraints=system_constraints,
                weight=1.0
            ),
            "Connectivity": QualityGateCategory(
                name="Connectivity",
                description="Network and broker connections",
                constraints=connectivity_constraints,
                weight=1.5
            )
        }
        
        # Initial display update
        self.update_categories_display()
    
    def _get_all_constraints(self) -> Dict[str, Constraint]:
        """Get all constraints as a flat dictionary"""
        
        all_constraints = {}
        for category in self.categories.values():
            for constraint in category.constraints:
                all_constraints[constraint.key] = constraint
        
        return all_constraints
    
    def update_constraint(self, constraint_key: str, data: Dict[str, Any]):
        """Update specific constraint"""
        
        with self.update_lock:
            all_constraints = self._get_all_constraints()
            
            if constraint_key in all_constraints:
                constraint = all_constraints[constraint_key]
                
                # Update constraint values
                if 'current_value' in data:
                    constraint.current_value = data['current_value']
                
                if 'status' in data:
                    constraint.status = ConstraintStatus(data['status'])
                
                constraint.last_checked = datetime.now()
                
                # Re-evaluate constraint
                self.evaluate_constraint(constraint)
                
                # Update display
                self.update_categories_display()
    
    def evaluate_constraint(self, constraint: Constraint):
        """Evaluate a constraint and update its status"""
        
        try:
            current = constraint.current_value
            expected = constraint.expected_value
            operator = constraint.operator
            
            # Evaluate based on operator
            if operator == "==":
                passed = current == expected
            elif operator == "!=":
                passed = current != expected
            elif operator == ">=":
                passed = current >= expected
            elif operator == "<=":
                passed = current <= expected
            elif operator == ">":
                passed = current > expected
            elif operator == "<":
                passed = current < expected
            elif operator == "in":
                passed = current in expected
            elif operator == "not_in":
                passed = current not in expected
            else:
                passed = False
            
            # Update status
            constraint.status = ConstraintStatus.PASSED if passed else ConstraintStatus.FAILED
            
        except Exception as e:
            constraint.status = ConstraintStatus.UNKNOWN
            print(f"Error evaluating constraint {constraint.key}: {e}")
    
    def check_all_constraints(self):
        """Check all constraints against current system state"""
        
        with self.update_lock:
            # Get current system state
            risk_metrics = state_manager.get_risk_metrics()
            connectivity = state_manager.get_connectivity_status()
            system_health = state_manager.get_system_health()
            
            # Update constraint values based on current state
            updates = {
                "dde_connection": connectivity.dde_connected,
                "symbol_count": connectivity.symbol_count,
                "data_freshness": (datetime.now() - (connectivity.last_update or datetime.now())).total_seconds(),
                "daily_risk_limit": abs(risk_metrics.daily_drawdown),
                "correlation_limit": risk_metrics.max_correlation,
                "portfolio_risk": risk_metrics.portfolio_risk,
                "cpu_usage": system_health.cpu_usage,
                "memory_usage": system_health.memory_usage,
                "event_queue_size": system_health.event_queue_size,
                "internet_connection": True,  # Simplified
                "broker_connection": connectivity.dde_connected  # Simplified
            }
            
            # Update constraints
            all_constraints = self._get_all_constraints()
            for key, value in updates.items():
                if key in all_constraints:
                    constraint = all_constraints[key]
                    constraint.current_value = value
                    constraint.last_checked = datetime.now()
                    self.evaluate_constraint(constraint)
            
            # Update display
            self.update_categories_display()
    
    def update_categories_display(self):
        """Update categories display"""
        
        # Clear existing category widgets
        for widget in self.categories_container.winfo_children():
            widget.destroy()
        
        # Create category widgets
        for category in self.categories.values():
            category_widget = QualityGateCategoryWidget(
                self.categories_container,
                category
            )
            category_widget.pack(fill="x", pady=5)
        
        # Calculate and update overall score
        self.update_overall_score()
    
    def update_overall_score(self):
        """Calculate and update overall readiness score"""
        
        if not self.categories:
            self.readiness_score.update_score(100.0)
            return
        
        # Weighted average of category scores
        total_weight = sum(cat.weight for cat in self.categories.values())
        weighted_sum = sum(cat.score * cat.weight for cat in self.categories.values())
        
        overall_score = weighted_sum / total_weight if total_weight > 0 else 0.0
        
        self.readiness_score.update_score(overall_score)
    
    def execute_fix_action(self, constraint_key: str, fix_action: str):
        """Execute fix action for constraint"""
        
        # Map fix actions to actual functions
        fix_actions = {
            "Reconnect DDE": self._fix_reconnect_dde,
            "Add more symbols": self._fix_add_symbols,
            "Refresh data feed": self._fix_refresh_data,
            "Reduce position sizes": self._fix_reduce_positions,
            "Diversify positions": self._fix_diversify_positions,
            "Lower risk per trade": self._fix_lower_risk,
            "Close unnecessary programs": self._fix_close_programs,
            "Restart application": self._fix_restart_application,
            "Process event backlog": self._fix_process_events,
            "Check network connection": self._fix_check_network,
            "Reconnect to broker": self._fix_reconnect_broker
        }
        
        if fix_action in fix_actions:
            try:
                fix_actions[fix_action]()
                show_info(f"Fix executed: {fix_action}")
                
                # Re-check constraints after fix
                self.after(1000, self.check_all_constraints)
                
            except Exception as e:
                show_warning(f"Fix failed: {e}")
        else:
            show_warning(f"Unknown fix action: {fix_action}")
    
    # Fix action implementations (simplified)
    def _fix_reconnect_dde(self):
        event_bus.publish("reconnect_dde", {}, "readiness_card")
    
    def _fix_add_symbols(self):
        event_bus.publish("add_default_symbols", {}, "readiness_card")
    
    def _fix_refresh_data(self):
        event_bus.publish("refresh_data_feed", {}, "readiness_card")
    
    def _fix_reduce_positions(self):
        event_bus.publish("reduce_all_positions", {"factor": 0.5}, "readiness_card")
    
    def _fix_diversify_positions(self):
        event_bus.publish("diversify_portfolio", {}, "readiness_card")
    
    def _fix_lower_risk(self):
        event_bus.publish("lower_risk_settings", {"new_limit": 1.5}, "readiness_card")
    
    def _fix_close_programs(self):
        show_info("Please close unnecessary programs manually")
    
    def _fix_restart_application(self):
        event_bus.publish("restart_application", {}, "readiness_card")
    
    def _fix_process_events(self):
        event_bus.publish("process_event_backlog", {}, "readiness_card")
    
    def _fix_check_network(self):
        show_info("Please check your network connection")
    
    def _fix_reconnect_broker(self):
        event_bus.publish("reconnect_broker", {}, "readiness_card")
    
    def force_refresh(self):
        """Force refresh of all constraints"""
        self.check_all_constraints()
        show_info("Constraints refreshed")
    
    def toggle_auto_refresh(self):
        """Toggle auto-refresh mode"""
        self.auto_refresh = not self.auto_refresh
        
        if self.auto_refresh:
            show_info("Auto-refresh enabled")
        else:
            show_info("Auto-refresh disabled")
    
    def start_update_loop(self):
        """Start the constraint checking loop"""
        
        if self.auto_refresh:
            self.check_all_constraints()
        
        # Schedule next update
        next_update_ms = int(self.refresh_interval * 1000)
        self.after(next_update_ms, self.start_update_loop)

# Integration function for main application
def integrate_readiness_card(parent_container) -> ReadinessCard:
    """
    Integration function to add readiness card to application
    
    Args:
        parent_container: Parent widget to contain the readiness card
        
    Returns:
        ReadinessCard instance
    """
    
    readiness_card = ReadinessCard(parent_container)
    readiness_card.pack(fill="both", expand=True, padx=10, pady=10)
    
    return readiness_card

⚡ PHASE 8: PERFORMANCE OPTIMIZATIONS (Day 7)
Step 8.1: Performance & Reliability Implementation
File: src/core/performance.py
python"""
Performance optimization and reliability enhancements for HUEY_P GUI
"""

import time
import threading
import psutil
import gc
from typing import Dict, List, Optional, Callable, Any
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from collections import deque, defaultdict
import queue
import weakref

from .event_bus import event_bus

@dataclass
class PerformanceMetrics:
    """Performance metrics tracking"""
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    frame_rate: float = 0.0
    event_processing_time: float = 0.0
    gui_response_time: float = 0.0
    last_gc_time: float = 0.0
    active_widgets: int = 0
    
@dataclass
class FrameBudget:
    """Frame budget management"""
    target_fps: float = 15.0
    frame_time_budget: float = field(init=False)
    current_frame_time: float = 0.0
    budget_exceeded_count: int = 0
    
    def __post_init__(self):
        self.frame_time_budget = 1.0 / self.target_fps

class UIScheduler:
    """UI update scheduler with frame budget management"""
    
    def __init__(self, target_fps: float = 15.0):
        self.frame_budget = FrameBudget(target_fps)
        self.update_queue: queue.PriorityQueue = queue.PriorityQueue()
        self.batch_updates: Dict[str, List[Callable]] = defaultdict(list)
        
        # Timing
        self.last_frame_time = time.time()
        self.frame_times: deque = deque(maxlen=60)  # Track last 60 frames
        
        # Threading
        self.scheduler_thread: Optional[threading.Thread] = None
        self.running = False
        
        # Performance tracking
        self.metrics = PerformanceMetrics()
        
    def start(self):
        """Start the UI scheduler"""
        if not self.running:
            self.running = True
            self.scheduler_thread = threading.Thread(target=self._scheduler_loop, daemon=True)
            self.scheduler_thread.start()
    
    def stop(self):
        """Stop the UI scheduler"""
        self.running = False
        if self.scheduler_thread:
            self.scheduler_thread.join(timeout=1.0)
    
    def schedule_update(self, priority: int, update_func: Callable, 
                       batch_key: Optional[str] = None):
        """
        Schedule a UI update with priority and optional batching
        
        Args:
            priority: Lower numbers = higher priority (0 = highest)
            update_func: Function to execute
            batch_key: Optional key for batching similar updates
        """
        
        current_time = time.time()
        
        if batch_key:
            # Batch similar updates
            self.batch_updates[batch_key].append(update_func)
        else:
            # Individual update
            self.update_queue.put((priority, current_time, update_func))
    
    def _scheduler_loop(self):
        """Main scheduler loop"""
        
        while self.running:
            frame_start = time.time()
            
            # Process batched updates first
            self._process_batched_updates()
            
            # Process individual updates within frame budget
            self._process_individual_updates(frame_start)
            
            # Update performance metrics
            self._update_performance_metrics(frame_start)
            
            # Sleep to maintain target FPS
            frame_time = time.time() - frame_start
            sleep_time = max(0, self.frame_budget.frame_time_budget - frame_time)
            
            if sleep_time > 0:
                time.sleep(sleep_time)
    
    def _process_batched_updates(self):
        """Process batched updates efficiently"""
        
        for batch_key, updates in self.batch_updates.items():
            if updates:
                # Execute all updates in batch
                for update_func in updates:
                    try:
                        update_func()
                    except Exception as e:
                        print(f"Batched update error: {e}")
                
                # Clear processed updates
                updates.clear()
    
    def _process_individual_updates(self, frame_start: float):
        """Process individual updates within frame budget"""
        
        processed_count = 0
        max_updates_per_frame = 10  # Limit to prevent frame drops
        
        while (not self.update_queue.empty() and 
               processed_count < max_updates_per_frame and
               (time.time() - frame_start) < (self.frame_budget.frame_time_budget * 0.8)):
            
            try:
                priority, timestamp, update_func = self.update_queue.get_nowait()
                update_func()
                processed_count += 1
                
            except queue.Empty:
                break
            except Exception as e:
                print(f"Individual update error: {e}")
    
    def _update_performance_metrics(self, frame_start: float):
        """Update performance metrics"""
        
        frame_time = time.time() - frame_start
        self.frame_times.append(frame_time)
        
        # Calculate FPS
        if len(self.frame_times) > 1:
            avg_frame_time = sum(self.frame_times) / len(self.frame_times)
            self.metrics.frame_rate = 1.0 / avg_frame_time if avg_frame_time > 0 else 0.0
        
        # Track budget violations
        if frame_time > self.frame_budget.frame_time_budget:
            self.frame_budget.budget_exceeded_count += 1
        
        self.frame_budget.current_frame_time = frame_time
        
        # Update system metrics periodically
        if int(frame_start) % 5 == 0:  # Every 5 seconds
            self._update_system_metrics()
    
    def _update_system_metrics(self):
        """Update system-level performance metrics"""
        
        try:
            # CPU and memory usage
            process = psutil.Process()
            self.metrics.cpu_usage = process.cpu_percent()
            self.metrics.memory_usage = process.memory_percent()
            
            # Garbage collection
            gc_start = time.time()
            collected = gc.collect()
            self.metrics.last_gc_time = time.time() - gc_start
            
            # Publish metrics
            event_bus.publish(
                "performance_metrics_update",
                {
                    "cpu_usage": self.metrics.cpu_usage,
                    "memory_usage": self.metrics.memory_usage,
                    "frame_rate": self.metrics.frame_rate,
                    "gc_collected": collected,
                    "budget_exceeded": self.frame_budget.budget_exceeded_count
                },
                source="ui_scheduler"
            )
            
        except Exception as e:
            print(f"System metrics update error: {e}")

class TableVirtualizer:
    """Virtualized table rendering for large datasets"""
    
    def __init__(self, table_widget, row_height: int = 25):
        self.table_widget = table_widget
        self.row_height = row_height
        
        # Data management
        self.all_data: List[Dict[str, Any]] = []
        self.filtered_data: List[Dict[str, Any]] = []
        self.visible_range: tuple = (0, 0)
        
        # UI state
        self.viewport_height = 300
        self.scroll_position = 0
        self.visible_rows = 12  # Number of rows visible at once
        self.buffer_rows = 5    # Extra rows for smooth scrolling
        
        # Rendered widgets cache
        self.row_widgets: Dict[int, Any] = {}
        self.widget_pool: List[Any] = []
        
    def set_data(self, data: List[Dict[str, Any]]):
        """Set the complete dataset"""
        self.all_data = data.copy()
        self.filtered_data = data.copy()
        self.update_virtual_display()
    
    def filter_data(self, filter_func: Callable[[Dict[str, Any]], bool]):
        """Apply filter to data"""
        self.filtered_data = [row for row in self.all_data if filter_func(row)]
        self.update_virtual_display()
    
    def update_virtual_display(self):
        """Update the virtualized display"""
        
        # Calculate visible range
        start_index = max(0, self.scroll_position - self.buffer_rows)
        end_index = min(
            len(self.filtered_data),
            self.scroll_position + self.visible_rows + self.buffer_rows
        )
        
        self.visible_range = (start_index, end_index)
        
        # Remove rows outside visible range
        self._remove_invisible_rows()
        
        # Add/update rows in visible range
        self._render_visible_rows()
    
    def _remove_invisible_rows(self):
        """Remove row widgets outside visible range"""
        
        start_index, end_index = self.visible_range
        
        for row_index in list(self.row_widgets.keys()):
            if row_index < start_index or row_index >= end_index:
                # Move widget back to pool
                widget = self.row_widgets.pop(row_index)
                self._return_widget_to_pool(widget)
    
    def _render_visible_rows(self):
        """Render rows in visible range"""
        
        start_index, end_index = self.visible_range
        
        for row_index in range(start_index, end_index):
            if row_index not in self.row_widgets and row_index < len(self.filtered_data):
                # Get widget from pool or create new
                widget = self._get_widget_from_pool()
                
                # Update widget with row data
                row_data = self.filtered_data[row_index]
                self._update_widget_data(widget, row_data)
                
                # Position widget
                y_position = row_index * self.row_height
                self._position_widget(widget, y_position)
                
                self.row_widgets[row_index] = widget
    
    def _get_widget_from_pool(self):
        """Get widget from pool or create new one"""
        
        if self.widget_pool:
            return self.widget_pool.pop()
        else:
            # Create new widget (implementation specific)
            return self._create_new_row_widget()
    
    def _return_widget_to_pool(self, widget):
        """Return widget to pool for reuse"""
        
        # Hide widget and add to pool
        self._hide_widget(widget)
        self.widget_pool.append(widget)
    
    def _create_new_row_widget(self):
        """Create new row widget (override in implementation)"""
        # This would be implemented based on the specific UI framework
        pass
    
    def _update_widget_data(self, widget, row_data: Dict[str, Any]):
        """Update widget with row data (override in implementation)"""
        # This would be implemented based on the specific UI framework
        pass
    
    def _position_widget(self, widget, y_position: int):
        """Position widget at y coordinate (override in implementation)"""
        # This would be implemented based on the specific UI framework
        pass
    
    def _hide_widget(self, widget):
        """Hide widget (override in implementation)"""
        # This would be implemented based on the specific UI framework
        pass
    
    def on_scroll(self, new_scroll_position: int):
        """Handle scroll events"""
        
        self.scroll_position = new_scroll_position // self.row_height
        self.update_virtual_display()

class UpdateCoalescer:
    """Coalesce rapid updates to prevent UI flooding"""
    
    def __init__(self, delay_ms: int = 100):
        self.delay_ms = delay_ms
        self.pending_updates: Dict[str, Callable] = {}
        self.timers: Dict[str, Any] = {}
        
    def coalesce_update(self, key: str, update_func: Callable, 
                       widget_ref: Optional[Any] = None):
        """
        Coalesce updates by key - only the latest update will execute
        
        Args:
            key: Unique key for the update type
            update_func: Function to execute
            widget_ref: Optional widget reference for cleanup
        """
        
        # Cancel existing timer for this key
        if key in self.timers:
            widget_ref.after_cancel(self.timers[key])
        
        # Store the latest update
        self.pending_updates[key] = update_func
        
        # Schedule execution
        if widget_ref:
            timer_id = widget_ref.after(self.delay_ms, lambda: self._execute_update(key))
            self.timers[key] = timer_id
    
    def _execute_update(self, key: str):
        """Execute pending update"""
        
        if key in self.pending_updates:
            try:
                update_func = self.pending_updates.pop(key)
                update_func()
            except Exception as e:
                print(f"Coalesced update error: {e}")
            finally:
                # Clean up timer reference
                self.timers.pop(key, None)

class MemoryManager:
    """Memory management and garbage collection optimization"""
    
    def __init__(self):
        self.widget_registry: weakref.WeakSet = weakref.WeakSet()
        self.large_objects: weakref.WeakValueDictionary = weakref.WeakValueDictionary()
        
        # GC tuning
        self.gc_threshold = 100_000_000  # 100MB
        self.last_gc_time = time.time()
        self.gc_interval = 30.0  # 30 seconds
        
        # Memory tracking
        self.peak_memory = 0.0
        self.memory_warnings = 0
        
        # Start monitoring
        self.start_monitoring()
    
    def register_widget(self, widget):
        """Register widget for memory tracking"""
        self.widget_registry.add(widget)
    
    def register_large_object(self, key: str, obj):
        """Register large object for tracking"""
        self.large_objects[key] = obj
    
    def start_monitoring(self):
        """Start memory monitoring thread"""
        
        def monitor_loop():
            while True:
                try:
                    self._check_memory_usage()
                    time.sleep(5.0)  # Check every 5 seconds
                except Exception as e:
                    print(f"Memory monitoring error: {e}")
        
        monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
        monitor_thread.start()
    
    def _check_memory_usage(self):
        """Check current memory usage and trigger GC if needed"""
        
        try:
            process = psutil.Process()
            memory_info = process.memory_info()
            current_memory = memory_info.rss  # Resident Set Size
            
            # Update peak memory
            if current_memory > self.peak_memory:
                self.peak_memory = current_memory
            
            # Check if GC is needed
            current_time = time.time()
            time_since_gc = current_time - self.last_gc_time
            
            if (current_memory > self.gc_threshold or 
                time_since_gc > self.gc_interval):
                
                self._perform_garbage_collection()
                self.last_gc_time = current_time
            
            # Check for memory warnings
            memory_percent = process.memory_percent()
            if memory_percent > 80.0:
                self.memory_warnings += 1
                
                if self.memory_warnings % 10 == 0:  # Every 10th warning
                    event_bus.publish(
                        "memory_warning",
                        {
                            "memory_percent": memory_percent,
                            "memory_mb": current_memory / (1024 * 1024),
                            "warning_count": self.memory_warnings
                        },
                        source="memory_manager"
                    )
        
        except Exception as e:
            print(f"Memory check error: {e}")
    
    def _perform_garbage_collection(self):
        """Perform optimized garbage collection"""
        
        gc_start = time.time()
        
        # Collect garbage in all generations
        collected_counts = []
        for generation in range(3):
            collected = gc.collect(generation)
            collected_counts.append(collected)
        
        gc_time = time.time() - gc_start
        
        # Report GC results
        event_bus.publish(
            "garbage_collection_completed",
            {
                "gc_time": gc_time,
                "collected_counts": collected_counts,
                "active_widgets": len(self.widget_registry),
                "large_objects": len(self.large_objects)
            },
            source="memory_manager"
        )
    
    def cleanup_expired_objects(self):
        """Clean up expired objects manually"""
        
        # Force cleanup of expired weak references
        expired_keys = []
        for key in list(self.large_objects.keys()):
            if key not in self.large_objects:
                expired_keys.append(key)
        
        return len(expired_keys)

class OfflineModeManager:
    """Manage offline mode and graceful degradation"""
    
    def __init__(self):
        self.is_offline = False
        self.offline_start_time: Optional[datetime] = None
        self.cached_data: Dict[str, Any] = {}
        self.offline_callbacks: List[Callable] = []
        self.online_callbacks: List[Callable] = []
        
        # Retry configuration
        self.retry_interval = 5.0  # seconds
        self.max_retry_attempts = 12  # 1 minute of retries
        self.current_retry_count = 0
        
        self.setup_event_handlers()
    
    def setup_event_handlers(self):
        """Setup event handlers for connectivity"""
        
        event_bus.subscribe("connectivity_lost", self._handle_connectivity_lost)
        event_bus.subscribe("connectivity_restored", self._handle_connectivity_restored)
    
    def _handle_connectivity_lost(self, event):
        """Handle connectivity loss"""
        
        if not self.is_offline:
            self.is_offline = True
            self.offline_start_time = datetime.now()
            self.current_retry_count = 0
            
            # Notify all offline callbacks
            for callback in self.offline_callbacks:
                try:
                    callback()
                except Exception as e:
                    print(f"Offline callback error: {e}")
            
            # Start retry loop
            self._start_retry_loop()
    
    def _handle_connectivity_restored(self, event):
        """Handle connectivity restoration"""
        
        if self.is_offline:
            self.is_offline = False
            offline_duration = datetime.now() - self.offline_start_time
            
            # Notify all online callbacks
            for callback in self.online_callbacks:
                try:
                    callback()
                except Exception as e:
                    print(f"Online callback error: {e}")
            
            # Report offline period
            event_bus.publish(
                "offline_period_ended",
                {
                    "duration_seconds": offline_duration.total_seconds(),
                    "retry_attempts": self.current_retry_count
                },
                source="offline_manager"
            )
    
    def register_offline_callback(self, callback: Callable):
        """Register callback for offline mode entry"""
        self.offline_callbacks.append(callback)
    
    def register_online_callback(self, callback: Callable):
        """Register callback for online mode restoration"""
        self.online_callbacks.append(callback)
    
    def cache_data(self, key: str, data: Any, ttl_seconds: float = 300.0):
        """Cache data for offline use"""
        
        expiry_time = datetime.now() + timedelta(seconds=ttl_seconds)
        self.cached_data[key] = {
            "data": data,
            "cached_at": datetime.now(),
            "expires_at": expiry_time
        }
    
    def get_cached_data(self, key: str) -> Optional[Any]:
        """Get cached data if available and not expired"""
        
        if key in self.cached_data:
            cache_entry = self.cached_data[key]
            
            if datetime.now() < cache_entry["expires_at"]:
                return cache_entry["data"]
            else:
                # Remove expired data
                del self.cached_data[key]
        
        return None
    
    def _start_retry_loop(self):
        """Start connectivity retry loop"""
        
        def retry_connection():
            if self.is_offline and self.current_retry_count < self.max_retry_attempts:
                self.current_retry_count += 1
                
                # Attempt reconnection
                event_bus.publish(
                    "attempt_reconnection",
                    {"attempt": self.current_retry_count},
                    source="offline_manager"
                )
                
                # Schedule next retry
                threading.Timer(self.retry_interval, retry_connection).start()
        
        # Start first retry
        threading.Timer(self.retry_interval, retry_connection).start()

# Global instances
ui_scheduler: Optional[UIScheduler] = None
update_coalescer = UpdateCoalescer()
memory_manager = MemoryManager()
offline_manager = OfflineModeManager()

def initialize_performance_systems(target_fps: float = 15.0):
    """Initialize all performance systems"""
    
    global ui_scheduler
    
    # Initialize UI scheduler
    ui_scheduler = UIScheduler(target_fps)
    ui_scheduler.start()
    
    # Setup performance monitoring
    event_bus.subscribe("performance_optimization_request", _handle_optimization_request)
    
    return {
        "ui_scheduler": ui_scheduler,
        "update_coalescer": update_coalescer,
        "memory_manager": memory_manager,
        "offline_manager": offline_manager
    }

def _handle_optimization_request(event):
    """Handle performance optimization requests"""
    
    optimization_type = event.data.get("type")
    
    if optimization_type == "memory_cleanup":
        memory_manager.cleanup_expired_objects()
        memory_manager._perform_garbage_collection()
    
    elif optimization_type == "reduce_frame_rate":
        if ui_scheduler:
            ui_scheduler.frame_budget.target_fps = max(5.0, ui_scheduler.frame_budget.target_fps * 0.8)
    
    elif optimization_type == "increase_frame_rate":
        if ui_scheduler:
            ui_scheduler.frame_budget.target_fps = min(60.0, ui_scheduler.frame_budget.target_fps * 1.2)

def cleanup_performance_systems():
    """Cleanup all performance systems"""
    
    global ui_scheduler
    
    if ui_scheduler:
        ui_scheduler.stop()
        ui_scheduler = None

🔧 PHASE 9: FINAL INTEGRATION (Day 7-8)
Step 9.1: Main Application Integration
File: src/main_application.py
python"""
Main HUEY_P Application with all modern GUI components integrated
"""

import customtkinter as ctk
import tkinter as tk
from typing import Dict, List, Optional, Any
import threading
import sys
import os
from datetime import datetime

# Import all GUI components
from .ui.risk_ribbon import RiskRibbon, integrate_risk_ribbon_with_main_window
from .ui.strength_tab import StrengthAndPercentChangeTab, integrate_strength_tab
from .ui.indicator_tab import IndicatorTabV2, integrate_indicator_tab_v2
from .ui.rule_matrix import RuleMatrixTab, integrate_rule_matrix_tab
from .ui.readiness_card import ReadinessCard, integrate_readiness_card
from .ui.command_palette import CommandPaletteManager, initialize_command_palette
from .ui.toast_manager import ToastManager, initialize_toast_manager

# Import core systems
from .core.event_bus import event_bus
from .core.state_manager import state_manager
from .core.performance import initialize_performance_systems, cleanup_performance_systems
from .themes.dark_theme import apply_dark_theme

# Import existing components (if they exist)
try:
    from .existing.price_manager import PriceManager
    from .existing.dde_client import DDEClient
    from .existing.indicator_engine import IndicatorEngine
    EXISTING_COMPONENTS_AVAILABLE = True
except ImportError:
    EXISTING_COMPONENTS_AVAILABLE = False
    print("Existing components not found - using mock implementations")

class MockComponents:
    """Mock implementations of existing components for testing"""
    
    class MockPriceManager:
        def __init__(self):
            self.symbols = ["EURUSD", "GBPUSD", "USDJPY", "USDCHF", "AUDUSD", "USDCAD", "NZDUSD", "EURGBP"]
            
        def get_available_symbols(self):
            return self.symbols
            
        def get_percent_changes(self, symbol):
            import random
            return {
                "15m": random.uniform(-1.0, 1.0),
                "1h": random.uniform(-2.0, 2.0),
                "4h": random.uniform(-3.0, 3.0),
                "8h": random.uniform(-4.0, 4.0),
                "12h": random.uniform(-5.0, 5.0),
                "24h": random.uniform(-6.0, 6.0)
            }
    
    class MockDDEClient:
        def __init__(self):
            self.connected = True
            
        def is_connected(self):
            return self.connected
            
        def connect(self):
            self.connected = True
            return True
            
        def disconnect(self):
            self.connected = False
    
    class MockIndicatorEngine:
        def __init__(self):
            pass
            
        def get_all_indicators(self):
            return {}

class HueyPMainApplication(ctk.CTk):
    """Main HUEY_P Trading Application with modern GUI"""
    
    def __init__(self):
        super().__init__()
        
        # Application configuration
        self.title("HUEY_P Trading System v2.0")
        self.geometry("1600x1000")
        self.minsize(1200, 800)
        
        # Apply theme
        apply_dark_theme()
        
        # Component references
        self.risk_ribbon: Optional[RiskRibbon] = None
        self.main_notebook: Optional[ctk.CTkTabview] = None
        self.command_palette: Optional[CommandPaletteManager] = None
        self.toast_manager: Optional[ToastManager] = None
        
        # Tab references
        self.strength_tab: Optional[StrengthAndPercentChangeTab] = None
        self.indicator_tab: Optional[IndicatorTabV2] = None
        self.rule_matrix_tab: Optional[RuleMatrixTab] = None
        self.readiness_card: Optional[ReadinessCard] = None
        
        # Backend component references
        self.price_manager = None
        self.dde_client = None
        self.indicator_engine = None
        
        # Application state
        self.is_initialized = False
        self.shutdown_requested = False
        
        # Initialize application
        self.initialize_application()
    
    def initialize_application(self):
        """Initialize the complete application"""
        
        try:
            # Step 1: Initialize core systems
            self.initialize_core_systems()
            
            # Step 2: Initialize backend components
            self.initialize_backend_components()
            
            # Step 3: Setup main UI
            self.setup_main_ui()
            
            # Step 4: Initialize GUI components
            self.initialize_gui_components()
            
            # Step 5: Setup event handlers
            self.setup_event_handlers()
            
            # Step 6: Start data simulation (for testing)
            self.start_data_simulation()
            
            # Step 7: Final setup
            self.finalize_initialization()
            
            self.is_initialized = True
            print("HUEY_P Application initialized successfully")
            
        except Exception as e:
            print(f"Application initialization failed: {e}")
            self.show_initialization_error(e)
    
    def initialize_core_systems(self):
        """Initialize core performance and management systems"""
        
        # Initialize performance systems
        performance_systems = initialize_performance_systems(target_fps=15.0)
        
        # Initialize toast manager
        self.toast_manager = initialize_toast_manager(self)
        
        # Initialize command palette
        self.command_palette = initialize_command_palette(self)
        
        print("Core systems initialized")
    
    def initialize_backend_components(self):
        """Initialize backend trading components"""
        
        if EXISTING_COMPONENTS_AVAILABLE:
            try:
                # Initialize real components
                self.price_manager = PriceManager()
                self.dde_client = DDEClient()
                self.indicator_engine = IndicatorEngine()
                
                print("Real backend components initialized")
                
            except Exception as e:
                print(f"Failed to initialize real components: {e}")
                self.initialize_mock_components()
        else:
            self.initialize_mock_components()
    
    def initialize_mock_components(self):
        """Initialize mock components for testing"""
        
        self.price_manager = MockComponents.MockPriceManager()
        self.dde_client = MockComponents.MockDDEClient()
        self.indicator_engine = MockComponents.MockIndicatorEngine()
        
        print("Mock backend components initialized")
    
    def setup_main_ui(self):
        """Setup main UI structure"""
        
        # Configure main window
        self.configure(fg_color="#0F1115")  # Dark surface color
        
        # Create main container
        main_container = ctk.CTkFrame(self, fg_color="transparent")
        main_container.pack(fill="both", expand=True)
        
        # Add risk ribbon at top
        self.risk_ribbon = integrate_risk_ribbon_with_main_window(
            main_container,
            emergency_callback=self.handle_emergency_stop
        )
        
        # Create main content area
        content_area = ctk.CTkFrame(main_container, fg_color="transparent")
        content_area.pack(fill="both", expand=True, padx=10, pady=(0, 10))
        
        # Create main notebook (tabs)
        self.main_notebook = ctk.CTkTabview(content_area)
        self.main_notebook.pack(fill="both", expand=True)
        
        print("Main UI structure created")
    
    def initialize_gui_components(self):
        """Initialize all GUI tab components"""
        
        # Add Risk Monitor tab (basic)
        self.add_risk_monitor_tab()
        
        # Add Strength & % Change tab
        self.strength_tab = integrate_strength_tab(self.main_notebook)
        
        # Add Indicators tab
        self.indicator_tab = integrate_indicator_tab_v2(self.main_notebook)
        
        # Add Rule Matrix tab
        self.rule_matrix_tab = integrate_rule_matrix_tab(self.main_notebook)
        
        # Add Readiness tab
        self.add_readiness_tab()
        
        # Add Settings tab
        self.add_settings_tab()
        
        # Set default tab
        self.main_notebook.set("🚨 Risk Monitor")
        
        print("GUI components initialized")
    
    def add_risk_monitor_tab(self):
        """Add risk monitor tab"""
        
        risk_tab = self.main_notebook.add("🚨 Risk Monitor")
        
        # Risk monitor content
        risk_content = ctk.CTkFrame(risk_tab)
        risk_content.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Title
        title_label = ctk.CTkLabel(
            risk_content,
            text="Risk Monitoring Dashboard",
            font=ctk.CTkFont(family="Arial", size=18, weight="bold")
        )
        title_label.pack(pady=20)
        
        # Risk metrics grid
        metrics_frame = ctk.CTkFrame(risk_content)
        metrics_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Configure grid
        metrics_frame.grid_columnconfigure((0, 1), weight=1)
        metrics_frame.grid_rowconfigure((0, 1), weight=1)
        
        # Current positions
        positions_frame = ctk.CTkFrame(metrics_frame)
        positions_frame.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=(0, 10))
        
        positions_title = ctk.CTkLabel(
            positions_frame,
            text="Current Positions",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold")
        )
        positions_title.pack(pady=(10, 5))
        
        positions_content = ctk.CTkLabel(
            positions_frame,
            text="No active positions\n\nPosition details will appear here\nwhen trades are active.",
            font=ctk.CTkFont(family="Arial", size=12),
            justify="center"
        )
        positions_content.pack(expand=True)
        
        # Risk summary
        risk_summary_frame = ctk.CTkFrame(metrics_frame)
        risk_summary_frame.grid(row=0, column=1, sticky="nsew", padx=(10, 0), pady=(0, 10))
        
        summary_title = ctk.CTkLabel(
            risk_summary_frame,
            text="Risk Summary",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold")
        )
        summary_title.pack(pady=(10, 5))
        
        summary_content = ctk.CTkLabel(
            risk_summary_frame,
            text="Daily Risk: 0.0%\nPortfolio Risk: 0.0%\nMax Correlation: 0.00\nAvailable Risk: 2.0%",
            font=ctk.CTkFont(family="Arial", size=12),
            justify="left"
        )
        summary_content.pack(expand=True)
        
        # Readiness card in bottom section
        readiness_section = ctk.CTkFrame(metrics_frame)
        readiness_section.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(10, 0))
        
        self.readiness_card = integrate_readiness_card(readiness_section)
    
    def add_readiness_tab(self):
        """Add dedicated readiness tab"""
        
        readiness_tab = self.main_notebook.add("🎯 Readiness")
        
        # Full readiness card
        full_readiness_card = integrate_readiness_card(readiness_tab)
    
    def add_settings_tab(self):
        """Add settings tab"""
        
        settings_tab = self.main_notebook.add("⚙️ Settings")
        
        # Settings content
        settings_content = ctk.CTkScrollableFrame(settings_tab)
        settings_content.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Title
        settings_title = ctk.CTkLabel(
            settings_content,
            text="Application Settings",
            font=ctk.CTkFont(family="Arial", size=18, weight="bold")
        )
        settings_title.pack(pady=(0, 20))
        
        # Theme settings
        theme_frame = ctk.CTkFrame(settings_content)
        theme_frame.pack(fill="x", pady=(0, 15))
        
        theme_title = ctk.CTkLabel(
            theme_frame,
            text="Theme Settings",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold")
        )
        theme_title.pack(anchor="w", padx=15, pady=(15, 10))
        
        # Theme selector
        theme_selector_frame = ctk.CTkFrame(theme_frame, fg_color="transparent")
        theme_selector_frame.pack(fill="x", padx=15, pady=(0, 15))
        
        ctk.CTkLabel(
            theme_selector_frame,
            text="Color Theme:",
            font=ctk.CTkFont(family="Arial", size=12)
        ).pack(side="left")
        
        theme_combo = ctk.CTkComboBox(
            theme_selector_frame,
            values=["Dark", "Light", "Auto"],
            command=self.change_theme
        )
        theme_combo.pack(side="right")
        theme_combo.set("Dark")
        
        # Performance settings
        performance_frame = ctk.CTkFrame(settings_content)
        performance_frame.pack(fill="x", pady=(0, 15))
        
        performance_title = ctk.CTkLabel(
            performance_frame,
            text="Performance Settings",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold")
        )
        performance_title.pack(anchor="w", padx=15, pady=(15, 10))
        
        # FPS setting
        fps_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        fps_frame.pack(fill="x", padx=15, pady=(0, 10))
        
        ctk.CTkLabel(
            fps_frame,
            text="Target FPS:",
            font=ctk.CTkFont(family="Arial", size=12)
        ).pack(side="left")
        
        fps_slider = ctk.CTkSlider(
            fps_frame,
            from_=5,
            to=60,
            number_of_steps=55,
            command=self.change_target_fps
        )
        fps_slider.pack(side="right", padx=(10, 0))
        fps_slider.set(15)
        
        # Update interval setting
        update_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        update_frame.pack(fill="x", padx=15, pady=(0, 15))
        
        ctk.CTkLabel(
            update_frame,
            text="Update Interval (ms):",
            font=ctk.CTkFont(family="Arial", size=12)
        ).pack(side="left")
        
        update_slider = ctk.CTkSlider(
            update_frame,
            from_=100,
            to=5000,
            number_of_steps=49,
            command=self.change_update_interval
        )
        update_slider.pack(side="right", padx=(10, 0))
        update_slider.set(1000)
        
        # Risk settings
        risk_settings_frame = ctk.CTkFrame(settings_content)
        risk_settings_frame.pack(fill="x", pady=(0, 15))
        
        risk_settings_title = ctk.CTkLabel(
            risk_settings_frame,
            text="Risk Management Settings",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold")
        )
        risk_settings_title.pack(anchor="w", padx=15, pady=(15, 10))
        
        # Daily risk limit
        daily_limit_frame = ctk.CTkFrame(risk_settings_frame, fg_color="transparent")
        daily_limit_frame.pack(fill="x", padx=15, pady=(0, 10))
        
        ctk.CTkLabel(
            daily_limit_frame,
            text="Daily Risk Limit (%):",
            font=ctk.CTkFont(family="Arial", size=12)
        ).pack(side="left")
        
        daily_limit_slider = ctk.CTkSlider(
            daily_limit_frame,
            from_=0.5,
            to=5.0,
            number_of_steps=45,
            command=self.change_daily_risk_limit
        )
        daily_limit_slider.pack(side="right", padx=(10, 0))
        daily_limit_slider.set(2.0)
        
        # Sound settings
        sound_frame = ctk.CTkFrame(settings_content)
        sound_frame.pack(fill="x", pady=(0, 15))
        
        sound_title = ctk.CTkLabel(
            sound_frame,
            text="Sound Settings",
            font=ctk.CTkFont(family="Arial", size=14, weight="bold")
        )
        sound_title.pack(anchor="w", padx=15, pady=(15, 10))
        
        # Enable sounds
        sound_enable_frame = ctk.CTkFrame(sound_frame, fg_color="transparent")
        sound_enable_frame.pack(fill="x", padx=15, pady=(0, 15))
        
        sound_switch = ctk.CTkSwitch(
            sound_enable_frame,
            text="Enable Audio Alerts",
            command=self.toggle_sounds
        )
        sound_switch.pack(side="left")
    
    def setup_event_handlers(self):
        """Setup application-level event handlers"""
        
        # Navigation events
        event_bus.subscribe("navigate_to_tab", self._handle_navigate_to_tab)
        
        # Emergency events
        event_bus.subscribe("emergency_stop_triggered", self._handle_emergency_stop)
        
        # Performance events
        event_bus.subscribe("performance_metrics_update", self._handle_performance_update)
        
        # Connection events
        event_bus.subscribe("dde_connection_lost", self._handle_connection_lost)
        event_bus.subscribe("dde_connection_restored", self._handle_connection_restored)
        
        # Window close event
        self.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        print("Event handlers setup complete")
    
    def start_data_simulation(self):
        """Start data simulation for testing (when using mock components)"""
        
        if not EXISTING_COMPONENTS_AVAILABLE:
            def simulate_data():
                """Simulate market data updates"""
                import random
                import time
                
                while not self.shutdown_requested:
                    try:
                        # Simulate risk updates
                        risk_data = {
                            "daily_drawdown": random.uniform(-2.5, 0.5),
                            "portfolio_risk": random.uniform(0.0, 3.0),
                            "max_correlation": random.uniform(0.2, 0.8),
                            "session_cap_used": random.uniform(0.0, 2.0)
                        }
                        
                        event_bus.publish("risk_update", risk_data, "simulation")
                        
                        # Simulate connectivity updates
                        connectivity_data = {
                            "dde_connected": random.choice([True, True, True, False]),  # Mostly connected
                            "symbol_count": random.randint(6, 10),
                            "last_update": datetime.now()
                        }
                        
                        event_bus.publish("connectivity_update", connectivity_data, "simulation")
                        
                        # Simulate market data updates
                        symbols = self.price_manager.get_available_symbols()
                        symbol_data = {}
                        
                        for symbol in symbols:
                            symbol_data[symbol] = self.price_manager.get_percent_changes(symbol)
                        
                        # Calculate currency strength
                        currency_strength = self.calculate_mock_currency_strength(symbol_data)
                        
                        market_data = {
                            "symbols": symbol_data,
                            "currency_strength": currency_strength
                        }
                        
                        event_bus.publish("market_data_update", market_data, "simulation")
                        
                        time.sleep(2.0)  # Update every 2 seconds
                        
                    except Exception as e:
                        print(f"Simulation error: {e}")
                        time.sleep(5.0)
            
            # Start simulation thread
            sim_thread = threading.Thread(target=simulate_data, daemon=True)
            sim_thread.start()
            
            print("Data simulation started")
    
    def calculate_mock_currency_strength(self, symbol_data):
        """Calculate mock currency strength from symbol data"""
        
        currencies = ["USD", "EUR", "GBP", "JPY", "CHF", "AUD", "CAD", "NZD"]
        currency_strength = {}
        
        for currency in currencies:
            # Calculate average strength across all timeframes and pairs
            strength_values = {}
            
            for timeframe in ["15m", "1h", "4h", "8h", "12h", "24h"]:
                total_change = 0.0
                count = 0
                
                for symbol, changes in symbol_data.items():
                    if currency in symbol:
                        change = changes.get(timeframe, 0.0)
                        
                        # If currency is base (first 3 chars), use positive change
                        # If currency is quote (last 3 chars), use negative change
                        if symbol.startswith(currency):
                            total_change += change
                        elif symbol.endswith(currency):
                            total_change -= change
                        
                        count += 1
                
                if count > 0:
                    strength_values[timeframe] = total_change / count
                else:
                    strength_values[timeframe] = 0.0
            
            currency_strength[currency] = strength_values
        
        return currency_strength
    
    def finalize_initialization(self):
        """Finalize application initialization"""
        
        # Set focus
        self.focus_set()
        
        # Show welcome message
        if self.toast_manager:
            self.toast_manager.show_success(
                "HUEY_P Trading System v2.0 initialized successfully!",
                duration=5.0
            )
        
        # Log initialization
        event_bus.publish(
            "application_initialized",
            {
                "version": "2.0",
                "components": [
                    "risk_ribbon",
                    "strength_tab", 
                    "indicator_tab",
                    "rule_matrix_tab",
                    "readiness_card",
                    "command_palette",
                    "toast_manager"
                ],
                "timestamp": datetime.now().isoformat()
            },
            source="main_application"
        )
    
    def show_initialization_error(self, error: Exception):
        """Show initialization error dialog"""
        
        # Create error dialog
        error_window = ctk.CTkToplevel(self)
        error_window.title("Initialization Error")
        error_window.geometry("500x300")
        error_window.transient(self)
        error_window.grab_set()
        
        # Error content
        error_frame = ctk.CTkFrame(error_window)
        error_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Title
        title_label = ctk.CTkLabel(
            error_frame,RetryThis response paused because Claude reached its max length for a message. Hit continue to nudge Claude along.Continue
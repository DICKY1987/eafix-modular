System Integration Plan: Merging Files into Complete Economic Calendar Automation
Executive Summary
Based on analysis of the three provided files, here's a detailed plan to combine them into a fully automated economic calendar system that achieves the goals outlined in our enhancement plan.
Current State Assessment
File Analysis:

python_calendar_system.py: Core system with scheduling, database, and web dashboard
ff_auto_downloader.py: Selenium-based ForexFactory automation (standalone)
python_calendar_system_patched.py: Production-hardened version with emergency controls

Critical Gap: The files are currently separate and don't integrate the automated download capability into the main system.
Integration Strategy
Phase 1: Foundation Merge (Week 1)
1.1 Base System Selection
Decision: Use python_calendar_system_patched.py as the foundation because it has:

Production-ready error handling
Emergency stop/resume controls
WebSocket broadcasting
Proper database UPSERT operations
File watching capabilities

1.2 Extract Download Components
Action: Extract key classes from ff_auto_downloader.py:
python# Create new file: calendar_downloader.py
class ForexFactoryDownloader:
    # Move from ff_auto_downloader.py
    
class CalendarProcessor:
    # Move processing logic from ff_auto_downloader.py
    
class AutomatedCalendarSystem:
    # Integrate into main system
1.3 Dependency Installation
Required additions to requirements.txt:
txtselenium==4.15.0
webdriver-manager==4.0.1
schedule==1.2.0
pandas==2.1.3
Phase 2: Core Integration (Week 1-2)
2.1 Modify Main System Configuration
File: python_calendar_system_patched.py
Add to SystemConfig:
pythonclass SystemConfig(BaseModel):
    # Existing fields...
    
    # New ForexFactory configuration
    forexfactory_enabled: bool = True
    forexfactory_url: str = "https://www.forexfactory.com/calendar"
    download_timeout: int = 30
    max_download_retries: int = 3
    webdriver_headless: bool = True
    
    # Processing configuration
    anticipation_hours: List[int] = [1, 2, 4]
    valid_impacts: List[str] = ["High", "Medium"]
    excluded_countries: List[str] = ["CHF"]
2.2 Replace Demo Import Function
Current code:
pythonasync def import_job():
    rows = sample_events_for_demo()  # Replace this
    ids = db.bulk_upsert(rows)
    await schedule_all_pending()
    await broadcast.push({"type": "import", "count": len(ids)})
New integrated version:
pythonasync def import_job():
    """Real calendar import using ForexFactory automation"""
    try:
        # Initialize downloader
        downloader = ForexFactoryDownloader(config)
        processor = CalendarProcessor(config)
        
        # Download calendar
        downloaded_file = await downloader.download_calendar_csv()
        if not downloaded_file:
            raise Exception("Failed to download calendar")
            
        # Process events
        processed_df = await processor.process_complete_calendar(downloaded_file)
        
        # Convert to database format
        rows = []
        for _, event in processed_df.iterrows():
            rows.append({
                "title": event['Title'],
                "country": event['Country'],
                "impact": event['Impact'],
                "event_date": pd.to_datetime(event['Date']).date(),
                "event_time": pd.to_datetime(event['Time']).time(),
                "trigger_time": event['EventDateTime'],
                "status": "PENDING",
                "parameter_set": {"strategy_id": event.get('StrategyID', '10101')},
                "quality_score": 0.9,
                "processing_notes": f"Auto-imported from {downloaded_file.name}"
            })
        
        # Save to database
        ids = db.bulk_upsert(rows)
        await schedule_all_pending()
        
        # Archive downloaded file
        archive_path = Path("./calendar_archive")
        archive_path.mkdir(exist_ok=True)
        archived = archive_path / f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{downloaded_file.name}"
        downloaded_file.rename(archived)
        
        await broadcast.push({"type": "import", "count": len(ids), "source": "forexfactory"})
        logging.info("Auto-imported %d events from ForexFactory", len(ids))
        
    except Exception as e:
        logging.error("Calendar import failed: %s", e)
        await broadcast.push({"type": "import_error", "error": str(e)})
        # Don't raise - let scheduler continue
2.3 Add Async Selenium Support
Create new file: async_downloader.py
pythonimport asyncio
from concurrent.futures import ThreadPoolExecutor
from ff_auto_downloader import ForexFactoryDownloader

class AsyncForexFactoryDownloader:
    """Async wrapper for Selenium-based downloader"""
    
    def __init__(self, config):
        self.config = config
        self.executor = ThreadPoolExecutor(max_workers=1)
    
    async def download_calendar_csv(self):
        """Run Selenium download in thread pool"""
        loop = asyncio.get_event_loop()
        downloader = ForexFactoryDownloader(self.config)
        
        return await loop.run_in_executor(
            self.executor,
            downloader.download_calendar_csv
        )
Phase 3: Enhanced Integration (Week 2)
3.1 Add Real-time Status Updates
Enhance the import process with detailed progress:
pythonasync def import_job_with_progress():
    """Enhanced import with real-time progress updates"""
    try:
        await broadcast.push({"type": "import_start"})
        
        # Download phase
        await broadcast.push({"type": "import_progress", "phase": "downloading", "progress": 10})
        downloader = AsyncForexFactoryDownloader(config)
        downloaded_file = await downloader.download_calendar_csv()
        
        if not downloaded_file:
            raise Exception("Download failed")
            
        await broadcast.push({"type": "import_progress", "phase": "processing", "progress": 50})
        
        # Processing phase
        processor = CalendarProcessor(config)
        processed_df = await asyncio.get_event_loop().run_in_executor(
            None, processor.process_complete_calendar, downloaded_file
        )
        
        await broadcast.push({"type": "import_progress", "phase": "saving", "progress": 80})
        
        # Database save phase
        rows = convert_df_to_db_format(processed_df, downloaded_file.name)
        ids = db.bulk_upsert(rows)
        await schedule_all_pending()
        
        await broadcast.push({"type": "import_complete", "count": len(ids), "progress": 100})
        
    except Exception as e:
        await broadcast.push({"type": "import_error", "error": str(e)})
        logging.error("Import failed: %s", e)
3.2 Add Configuration Validation
Before system startup, validate configuration:
pythondef validate_selenium_setup():
    """Validate Selenium can run properly"""
    try:
        from selenium import webdriver
        from selenium.webdriver.chrome.options import Options
        from webdriver_manager.chrome import ChromeDriverManager
        
        # Test Chrome driver installation
        ChromeDriverManager().install()
        return True
    except Exception as e:
        logging.error("Selenium setup validation failed: %s", e)
        return False

@app.on_event("startup")
async def on_startup():
    # Validate Selenium if ForexFactory enabled
    if config.forexfactory_enabled:
        if not validate_selenium_setup():
            logging.warning("Selenium not available, disabling ForexFactory auto-download")
            config.forexfactory_enabled = False
    
    # Rest of startup logic...
Phase 4: Advanced Features (Week 3)
4.1 Add Retry Logic and Circuit Breaker
Implement robust download retry:
pythonclass DownloadCircuitBreaker:
    def __init__(self, failure_threshold=3, recovery_time=3600):
        self.failure_count = 0
        self.failure_threshold = failure_threshold
        self.recovery_time = recovery_time
        self.last_failure = None
        self.is_open = False
    
    def can_execute(self):
        if not self.is_open:
            return True
        
        if self.last_failure and (datetime.now() - self.last_failure).seconds > self.recovery_time:
            self.is_open = False
            self.failure_count = 0
            return True
        
        return False
    
    def record_success(self):
        self.failure_count = 0
        self.is_open = False
    
    def record_failure(self):
        self.failure_count += 1
        self.last_failure = datetime.now()
        if self.failure_count >= self.failure_threshold:
            self.is_open = True

# Add to import job
circuit_breaker = DownloadCircuitBreaker()

async def import_job_with_circuit_breaker():
    if not circuit_breaker.can_execute():
        logging.warning("Download circuit breaker is open, skipping import")
        await broadcast.push({"type": "import_skipped", "reason": "circuit_breaker"})
        return
    
    try:
        # ... existing import logic ...
        circuit_breaker.record_success()
    except Exception as e:
        circuit_breaker.record_failure()
        raise
4.2 Add Health Monitoring
Create comprehensive system health tracking:
pythonclass SystemHealthMonitor:
    def __init__(self, db, config):
        self.db = db
        self.config = config
        self.metrics = {}
    
    async def collect_metrics(self):
        """Collect system health metrics"""
        now = datetime.now(timezone.utc)
        
        # Database metrics
        events = self.db.list_all()
        pending_count = len([e for e in events if e['status'] == 'PENDING'])
        triggered_count = len([e for e in events if e['status'] == 'TRIGGERED'])
        
        # Import metrics
        last_import = max([datetime.fromisoformat(e['created_at']) for e in events], default=now)
        time_since_import = (now - last_import).total_seconds() / 3600  # hours
        
        # Circuit breaker status
        cb_status = "OPEN" if circuit_breaker.is_open else "CLOSED"
        
        self.metrics = {
            "timestamp": now.isoformat(),
            "total_events": len(events),
            "pending_events": pending_count,
            "triggered_events": triggered_count,
            "hours_since_import": time_since_import,
            "circuit_breaker": cb_status,
            "forexfactory_enabled": self.config.forexfactory_enabled,
            "emergency_stop": _ESTOP["active"]
        }
        
        return self.metrics

# Add health endpoint
health_monitor = SystemHealthMonitor(db, config)

@app.get("/health")
async def get_health():
    return await health_monitor.collect_metrics()
Phase 5: Testing and Validation (Week 3-4)
5.1 Create Integration Tests
File: test_integration.py
pythonimport pytest
import asyncio
from pathlib import Path
import tempfile

@pytest.mark.asyncio
async def test_full_automation_pipeline():
    """Test complete automation from download to signal export"""
    
    # Setup test environment
    with tempfile.TemporaryDirectory() as tmpdir:
        test_config = SystemConfig(
            database_path=f"{tmpdir}/test.db",
            signals_export_path=f"{tmpdir}/signals",
            forexfactory_enabled=False  # Use mock for testing
        )
        
        test_db = DB(test_config.database_path)
        
        # Mock download data
        mock_events = [
            {
                "title": "Test NFP",
                "country": "USD",
                "impact": "High",
                "event_date": (datetime.now() + timedelta(hours=1)).date(),
                "event_time": (datetime.now() + timedelta(hours=1)).time(),
                "trigger_time": datetime.now() + timedelta(minutes=5),
                "status": "PENDING"
            }
        ]
        
        # Test database operations
        ids = test_db.bulk_upsert(mock_events)
        assert len(ids) == 1
        
        # Test event retrieval
        pending = test_db.get_pending_events()
        assert len(pending) == 1
        assert pending[0]["title"] == "Test NFP"
        
        # Test signal export
        integration = MT4Integration(test_config.signals_export_path)
        signal_file = await integration.export_signal(pending[0])
        assert signal_file.exists()

@pytest.mark.asyncio
async def test_selenium_download():
    """Test actual ForexFactory download (integration test)"""
    if not SELENIUM_AVAILABLE:
        pytest.skip("Selenium not available")
    
    downloader = ForexFactoryDownloader(Config())
    
    # This will actually hit ForexFactory - use sparingly
    result = await asyncio.get_event_loop().run_in_executor(
        None, downloader.download_calendar_csv
    )
    
    assert result is not None
    assert result.exists()
    assert result.suffix == '.csv'
5.2 Create Deployment Scripts
File: deploy.py
python#!/usr/bin/env python3
"""Deployment script for the integrated calendar system"""

import subprocess
import sys
from pathlib import Path

def install_dependencies():
    """Install required dependencies"""
    requirements = [
        "fastapi==0.104.1",
        "uvicorn==0.24.0", 
        "pandas==2.1.3",
        "pydantic==2.5.0",
        "apscheduler==3.10.4",
        "selenium==4.15.0",
        "webdriver-manager==4.0.1",
        "watchdog==3.0.0",
        "pyyaml==6.0.1"
    ]
    
    for req in requirements:
        subprocess.check_call([sys.executable, "-m", "pip", "install", req])

def setup_directories():
    """Create required directories"""
    dirs = [
        "./signals_out",
        "./signals_in", 
        "./calendar_archive",
        "./logs",
        "./static"
    ]
    
    for dir_path in dirs:
        Path(dir_path).mkdir(exist_ok=True)

def validate_chrome():
    """Validate Chrome/Chromium is available"""
    try:
        from selenium import webdriver
        from webdriver_manager.chrome import ChromeDriverManager
        ChromeDriverManager().install()
        print("✓ Chrome WebDriver setup successful")
        return True
    except Exception as e:
        print(f"✗ Chrome WebDriver setup failed: {e}")
        return False

def main():
    print("=== Economic Calendar System Deployment ===")
    
    print("1. Installing dependencies...")
    install_dependencies()
    
    print("2. Setting up directories...")
    setup_directories()
    
    print("3. Validating Chrome setup...")
    chrome_ok = validate_chrome()
    
    print("4. Creating default configuration...")
    config = SystemConfig.load_or_create()
    
    if chrome_ok:
        print("✓ System ready for full automation")
    else:
        print("⚠ System ready but ForexFactory auto-download disabled")
        config.forexfactory_enabled = False
        export_configuration(config)
    
    print("=== Deployment Complete ===")
    print("Run with: python python_calendar_system_integrated.py")

if __name__ == "__main__":
    main()
Implementation Timeline
Week 1: Foundation

 Extract components from ff_auto_downloader.py
 Integrate into python_calendar_system_patched.py
 Replace demo import with real ForexFactory automation
 Add async Selenium wrapper
 Basic error handling

Week 2: Enhancement

 Add real-time progress updates
 Implement configuration validation
 Add retry logic and circuit breaker
 Create health monitoring endpoints

Week 3: Testing

 Create comprehensive integration tests
 Add deployment automation
 Performance testing and optimization
 Documentation and runbooks

Week 4: Production

 Security review and hardening
 Monitoring and alerting setup
 Backup and recovery procedures
 Go-live preparation

Risk Mitigation
Selenium Dependency Risk:

Graceful fallback to manual file discovery if Selenium fails
Circuit breaker prevents continuous retry failures
Health monitoring alerts on download failures

ForexFactory Changes Risk:

CSS selector arrays handle website layout changes
Error logging captures specific failure modes
Manual override capability maintained

Performance Risk:

Selenium runs in thread pool to avoid blocking
Download timeout prevents hanging operations
Resource cleanup ensures no memory leaks

Success Criteria
Functional Requirements:

Automated calendar download every Sunday 12 PM
Real-time event processing and signal generation
Emergency stop/resume functionality
Web dashboard with live updates

Quality Requirements:

95%+ download success rate
Sub-30 second download completion
Zero data corruption or duplication
Complete audit trail for all operations

This plan provides a systematic approach to merging the three files into a production-ready, fully automated economic calendar system that achieves the goals outlined in our original enhancement plan.
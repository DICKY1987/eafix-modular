// doc_id: DOC-LEGACY-0091
Perfect! I can see from your project knowledge that you already have a solid foundation with the modular indicator architecture. Let me brainstorm a standardized interface design that builds on your existing base_indicator.py, indicator_engine.py, and GUI structure.
Standardized Indicator Interface Design
1. Core Interface Contract (Enhanced Base Class)
python# Enhanced base_indicator.py
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Tuple
from enum import Enum
from dataclasses import dataclass

class IndicatorCategory(Enum):
    TREND = "trend"
    OSCILLATOR = "oscillator" 
    VOLATILITY = "volatility"
    VOLUME = "volume"
    CUSTOM = "custom"
    CURRENCY_STRENGTH = "currency_strength"
    PERCENT_CHANGE = "percent_change"

@dataclass
class IndicatorMetadata:
    name: str
    category: IndicatorCategory
    description: str
    parameters: Dict[str, Any]
    output_fields: List[str]
    time_windows: List[str]  # For percent change indicators
    display_config: Dict[str, Any]
    version: str = "1.0"

class StandardIndicatorInterface(ABC):
    def __init__(self, symbol: str, metadata: IndicatorMetadata):
        self.symbol = symbol
        self.metadata = metadata
        self.is_ready = False
        self.last_values = {}
        
    @abstractmethod
    def calculate(self, price_data: Dict) -> Dict[str, Any]:
        """Calculate indicator values"""
        pass
    
    @abstractmethod
    def get_display_config(self) -> Dict[str, Any]:
        """Return GUI display configuration"""
        pass
    
    @abstractmethod  
    def get_signal_states(self) -> Dict[str, str]:
        """Return current signal states for ML/trading logic"""
        pass
    
    def validate_parameters(self) -> bool:
        """Validate indicator parameters"""
        return True
    
    def get_required_history_bars(self) -> int:
        """Return minimum bars needed for calculation"""
        return 50
2. Percent Change Indicator (Your Core Requirement)
python# indicators/percent_change.py
class PercentChangeIndicator(StandardIndicatorInterface):
    def __init__(self, symbol: str):
        metadata = IndicatorMetadata(
            name="Percent Change Multi-Window",
            category=IndicatorCategory.PERCENT_CHANGE,
            description="Percent change over multiple time windows",
            parameters={
                "windows_minutes": [15, 60, 240, 480, 720, 1440]  # 15m, 1h, 4h, 8h, 12h, 24h
            },
            output_fields=["pct_15m", "pct_1h", "pct_4h", "pct_8h", "pct_12h", "pct_24h"],
            time_windows=["15m", "1h", "4h", "8h", "12h", "24h"],
            display_config={
                "chart_type": "table",
                "color_coding": True,
                "decimal_places": 3
            }
        )
        super().__init__(symbol, metadata)
        self.price_history = []
        
    def calculate(self, price_data: Dict) -> Dict[str, Any]:
        current_price = (price_data['bid'] + price_data['ask']) / 2
        current_time = price_data['timestamp']
        
        # Store price point
        self.price_history.append({'price': current_price, 'time': current_time})
        
        # Calculate percent changes for each window
        results = {}
        for minutes, label in zip(self.metadata.parameters["windows_minutes"], 
                                  self.metadata.output_fields):
            historical_price = self._get_price_at_time(current_time - minutes * 60)
            if historical_price:
                pct_change = ((current_price - historical_price) / historical_price) * 100
                results[label] = round(pct_change, 4)
            else:
                results[label] = None
                
        self.last_values = results
        return results
    
    def get_signal_states(self) -> Dict[str, str]:
        """Bucket percent changes into states for ML"""
        states = {}
        for field, value in self.last_values.items():
            if value is not None:
                if value > 1.0:
                    states[f"{field}_state"] = "strong_up"
                elif value > 0.3:
                    states[f"{field}_state"] = "up"
                elif value > -0.3:
                    states[f"{field}_state"] = "sideways"
                elif value > -1.0:
                    states[f"{field}_state"] = "down"
                else:
                    states[f"{field}_state"] = "strong_down"
        return states
3. Currency Strength Indicator
python# indicators/currency_strength.py
class CurrencyStrengthIndicator(StandardIndicatorInterface):
    def __init__(self, base_currency: str, dde_symbols: List[str]):
        metadata = IndicatorMetadata(
            name=f"{base_currency} Strength Index",
            category=IndicatorCategory.CURRENCY_STRENGTH,
            description=f"Relative strength of {base_currency} across pairs",
            parameters={
                "base_currency": base_currency,
                "pairs": dde_symbols,
                "windows_minutes": [15, 60, 240, 480, 720, 1440]
            },
            output_fields=[f"strength_{w}" for w in ["15m", "1h", "4h", "8h", "12h", "24h"]],
            time_windows=["15m", "1h", "4h", "8h", "12h", "24h"],
            display_config={
                "chart_type": "line",
                "oscillator_bands": [-2, 0, 2],
                "color_scheme": "strength"
            }
        )
        super().__init__(base_currency, metadata)
        self.base_currency = base_currency
        self.pair_indicators = {}
        
    def calculate(self, all_pair_data: Dict[str, Dict]) -> Dict[str, Any]:
        """Calculate currency strength from all pairs containing base currency"""
        strength_values = {}
        
        for window in ["15m", "1h", "4h", "8h", "12h", "24h"]:
            pair_changes = []
            
            for pair, data in all_pair_data.items():
                if self.base_currency in pair:
                    pct_change = data.get(f"pct_{window}")
                    if pct_change is not None:
                        # Adjust sign based on base currency position
                        if pair.startswith(self.base_currency):
                            pair_changes.append(pct_change)
                        else:
                            pair_changes.append(-pct_change)
            
            # Calculate average strength
            if pair_changes:
                avg_strength = sum(pair_changes) / len(pair_changes)
                strength_values[f"strength_{window}"] = avg_strength
                
        self.last_values = strength_values
        return strength_values
4. Plugin Registry System
python# indicator_registry.py
class IndicatorRegistry:
    def __init__(self):
        self._indicators = {}
        self._categories = {}
        self.register_built_ins()
    
    def register_indicator(self, indicator_class, metadata: IndicatorMetadata):
        """Register a new indicator class"""
        self._indicators[metadata.name] = {
            'class': indicator_class,
            'metadata': metadata
        }
        
        if metadata.category not in self._categories:
            self._categories[metadata.category] = []
        self._categories[metadata.category].append(metadata.name)
    
    def create_indicator(self, name: str, symbol: str, **kwargs) -> StandardIndicatorInterface:
        """Factory method to create indicator instances"""
        if name not in self._indicators:
            raise ValueError(f"Unknown indicator: {name}")
            
        indicator_info = self._indicators[name]
        return indicator_info['class'](symbol, **kwargs)
    
    def get_available_indicators(self) -> Dict[str, List[str]]:
        """Get all available indicators by category"""
        return self._categories.copy()
    
    def register_built_ins(self):
        """Register all built-in indicators"""
        # Register existing indicators
        from indicators.moving_averages import SMA, EMA
        from indicators.oscillators import RSI, MACD
        from indicators.percent_change import PercentChangeIndicator
        from indicators.currency_strength import CurrencyStrengthIndicator
        
        # Auto-register using decorator pattern
        for indicator_class in [SMA, EMA, RSI, MACD, PercentChangeIndicator]:
            if hasattr(indicator_class, '_metadata'):
                self.register_indicator(indicator_class, indicator_class._metadata)

# Global registry instance
indicator_registry = IndicatorRegistry()
5. Enhanced GUI Tab Interface
python# Enhanced main_tab.py - Indicators Tab
class IndicatorsTab:
    def __init__(self, parent, dde_client, price_manager):
        self.frame = ttk.Frame(parent)
        self.dde_client = dde_client
        self.price_manager = price_manager
        self.active_indicators = {}
        
        self.setup_ui()
        
    def setup_ui(self):
        # Left panel: Available indicators by category
        self.create_indicator_browser()
        
        # Center panel: Active indicators table
        self.create_active_indicators_panel()
        
        # Right panel: Real-time values display
        self.create_realtime_display()
        
        # Bottom panel: Percent change matrix and currency strength
        self.create_percent_change_matrix()
        self.create_currency_strength_display()
    
    def create_indicator_browser(self):
        """Tree view of available indicators by category"""
        tree = ttk.Treeview(self.frame)
        
        categories = indicator_registry.get_available_indicators()
        for category, indicators in categories.items():
            cat_node = tree.insert('', 'end', text=category.value.title())
            for indicator in indicators:
                tree.insert(cat_node, 'end', text=indicator, 
                           values=(indicator,))
        
        # Double-click to add indicator
        tree.bind('<Double-1>', self.on_add_indicator)
        
    def create_percent_change_matrix(self):
        """Matrix showing percent changes for all pairs and timeframes"""
        matrix_frame = ttk.LabelFrame(self.frame, text="Percent Change Matrix")
        
        # Create table with pairs as rows, timeframes as columns
        columns = ['Pair', '15m', '1h', '4h', '8h', '12h', '24h']
        self.pct_tree = ttk.Treeview(matrix_frame, columns=columns, show='headings')
        
        for col in columns:
            self.pct_tree.heading(col, text=col)
            self.pct_tree.column(col, width=80)
    
    def create_currency_strength_display(self):
        """Currency strength indicators for each major currency"""
        strength_frame = ttk.LabelFrame(self.frame, text="Currency Strength")
        
        currencies = ['USD', 'EUR', 'GBP', 'JPY', 'AUD', 'CAD', 'CHF', 'NZD']
        self.strength_displays = {}
        
        for i, currency in enumerate(currencies):
            frame = ttk.Frame(strength_frame)
            frame.grid(row=i//4, column=i%4, padx=5, pady=5)
            
            ttk.Label(frame, text=currency, font=('Arial', 12, 'bold')).pack()
            
            # Strength gauge/bar
            strength_var = tk.DoubleVar()
            strength_bar = ttk.Progressbar(frame, variable=strength_var, 
                                         length=100, mode='determinate')
            strength_bar.pack()
            
            # Numeric value
            value_label = ttk.Label(frame, text="0.00%")
            value_label.pack()
            
            self.strength_displays[currency] = {
                'var': strength_var,
                'label': value_label,
                'bar': strength_bar
            }
6. Integration with Existing System
python# Enhanced indicator_engine.py
class EnhancedIndicatorEngine:
    def __init__(self, price_manager):
        self.price_manager = price_manager
        self.indicators = {}
        self.percent_change_indicators = {}
        self.currency_strength_indicators = {}
        
    def add_indicator(self, symbol: str, indicator_name: str, **params):
        """Add indicator using registry"""
        indicator = indicator_registry.create_indicator(
            indicator_name, symbol, **params
        )
        
        key = f"{symbol}_{indicator_name}"
        self.indicators[key] = indicator
        
    def setup_core_indicators(self, symbols: List[str]):
        """Setup percent change and currency strength for DDE symbols"""
        # Add percent change for each symbol
        for symbol in symbols:
            pct_indicator = PercentChangeIndicator(symbol)
            self.percent_change_indicators[symbol] = pct_indicator
            
        # Add currency strength indicators
        currencies = self._extract_currencies(symbols)
        for currency in currencies:
            strength_indicator = CurrencyStrengthIndicator(currency, symbols)
            self.currency_strength_indicators[currency] = strength_indicator
    
    def update_all_indicators(self, symbol: str, price_data: Dict):
        """Update all indicators for a symbol"""
        # Update percent change
        if symbol in self.percent_change_indicators:
            pct_results = self.percent_change_indicators[symbol].calculate(price_data)
            
        # Update currency strength (needs all pair data)
        all_pair_data = self._collect_all_pair_percent_changes()
        for currency, indicator in self.currency_strength_indicators.items():
            indicator.calculate(all_pair_data)
            
        # Update other indicators
        for key, indicator in self.indicators.items():
            if key.startswith(symbol):
                indicator.calculate(price_data)
Benefits of This Design:

Plug & Play: New indicators just need to inherit from StandardIndicatorInterface
Consistent GUI: All indicators get standard display panels automatically
ML Ready: Signal states are standardized for your probability tables
DDE Centered: Percent change and currency strength automatically update from DDE feed
Extensible: Easy to add new categories and display types

This gives you the foundation to drop in your percent change windows and currency strength calculations while maintaining the plug-and-play architecture you want. 